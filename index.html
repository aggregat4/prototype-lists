<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Prototype Lists</title>
        <link rel="stylesheet" href="./styles.css" />
    </head>
    <body>
        <div class="lists-app" data-role="lists-app">
            <aside class="lists-sidebar" data-role="sidebar">
                <div class="sidebar-header">
                    <h1 class="sidebar-title">Lists</h1>
                </div>
                <div class="sidebar-section sidebar-search">
                    <label class="sidebar-field">
                        <input
                            type="search"
                            class="sidebar-search-input"
                            placeholder="Search across all listsâ€¦"
                            aria-label="Global search"
                            data-role="global-search"
                        />
                    </label>
                </div>
                <nav class="sidebar-section sidebar-lists" aria-label="Available lists">
                    <ul class="sidebar-list" data-role="sidebar-list"></ul>
                </nav>
                <div class="sidebar-section sidebar-actions">
                    <button type="button" data-role="add-list">
                        Add list
                    </button>
                    <button type="button" class="danger" data-role="delete-list">
                        Delete list
                    </button>
                </div>
            </aside>
            <main class="lists-main" data-role="main">
                <header class="lists-main-header">
                    <h2 class="lists-main-title" data-role="active-list-title"></h2>
                </header>
                <div class="lists-container" data-role="lists-container"></div>
            </main>
        </div>

        <div class="move-dialog" data-role="move-dialog" hidden>
            <div class="move-dialog__backdrop" data-role="move-dialog-backdrop"></div>
            <div
                class="move-dialog__content"
                role="dialog"
                aria-modal="true"
                aria-labelledby="move-dialog-title"
                aria-describedby="move-dialog-description"
                tabindex="-1"
            >
                <h2 id="move-dialog-title" class="move-dialog__title">Move Task</h2>
                <p id="move-dialog-description" class="move-dialog__description">
                    Select a destination list for this task. Use the arrow keys to choose, then
                    press Enter.
                </p>
                <ul class="move-dialog__options" data-role="move-dialog-options"></ul>
                <div class="move-dialog__actions">
                    <button
                        type="button"
                        class="move-dialog__cancel"
                        data-role="move-dialog-cancel"
                    >
                        Cancel
                    </button>
                </div>
            </div>
        </div>
        <script type="module">
            import { html, render } from "./vendor/lit-html.js";
            import DraggableBehavior, { FlipAnimator } from "./lib/drag-behavior.js";
            import InlineTextEditor from "./lib/inline-text-editor.js";
            import { ListRepository } from "./lib/app/list-repository.js";
            import { DEFAULT_DB_NAME as LISTS_DB_NAME } from "./lib/storage/list-storage.js";
            const PROTOTYPE_TASK_TEXTS = [
                "Refill the bird feeder before the sparrows file another formal request.",
                "Check the fridge light still turns off, preferably without crawling inside again.",
                "Return the umbrella to the hallway, where it insists it lives.",
                "Water the fern before it submits another strongly worded letter to the radiator.",
                "Update the shopping list to include milk, bread, and a moderately sensible hat.",
                "Verify that the kettle boils water and not, as it occasionally attempts, good intentions.",
                "Organize the cutlery drawer so the forks don't keep holding union meetings.",
                "Empty the dishwasher before it begins drafting poetry about neglect.",
                "Set the alarm clock, reminding it gently that no one enjoys its personality.",
                "Take the bins out, though they are increasingly insistent they'd rather stay in.",
                "Test the smoke detector by asking it politely to explain its worldview.",
                "Send an email to the electricity meter thanking it for its tireless blinking.",
                "Sharpen pencils so they feel prepared for anything, including international diplomacy.",
                "Update the calendar to reflect the current year, not the one the cat prefers.",
                "Polish the windows until they are clear about their long-term career goals.",
                "Check the washing machine for socks that have declared independence.",
                "Restock the biscuit tin before negotiations with visitors turn awkward.",
                "Feed the goldfish, who has recently taken to sighing at odd intervals.",
                "Write down the Wi-Fi password in case it decides to change its name again.",
                "Vacuum the carpet before it develops further geological features.",
            ];

            const WEEKEND_PROJECT_TEXTS = [
                "Patch the garden fence before the neighbor's cat launches another inspection.",
                "Clear the garage path so the bikes stop living under a tarp monarchy.",
                "Label the mystery cables basket before it becomes household folklore.",
                "Sand the coffee table so splinters stop campaigning for attention.",
                "Plan the herb bed before the mint declares full sovereignty.",
                "Paint the hallway sample squares to convince the walls to commit.",
                "Wash the car until it remembers it's actually blue.",
                "Tighten the wobbly chairs before guests develop sea legs.",
                "Test the fire pit so marshmallows can renew their contract.",
                "Replace the porch light bulb before the moth council files grievances.",
                "Organize board games so the dice stop backpacking through the house.",
                "Clean the aquarium filter before the fish union organizes a strike.",
                "Inventory the toolbox to confirm the 14mm socket still exists.",
                "Fix the squeaky door that narrates every midnight snack.",
                "Trim the hedges before they audition as stage curtains.",
                "Sort camping gear into piles of 'useful' and 'optimistic'.",
                "Re-string the clothesline before the laundry takes flight.",
                "Tune the piano so middle C stops sounding philosophical.",
                "Swap batteries in the fairy lights before they become existential.",
                "Back up family photos before the cloud picks favorites.",
            ];

            const WORK_FOLLOWUP_TEXTS = [
                "Email the design draft to Isla before the mockups develop sentience.",
                "Confirm sprint goals with DevOps so the servers stay optimistic.",
                "Schedule the retro while memories of the bugs are still polite.",
                "Review the analytics deck before stakeholders wield highlighters.",
                "Update the roadmap to reflect the features marketing already announced.",
                "Ping legal about the release notes before we ship interpretive poetry.",
                "Organize user interviews so transcripts arrive before next quarter.",
                "Check in with QA about flaky tests that believe in free will.",
                "Draft the onboarding doc so newcomers stop learning via treasure hunt.",
                "Refresh the team wiki links that redirect to archaeological findings.",
                "Finalize the budget sheet before finance asks for interpretive dance.",
                "Reply to the vendor with polite enthusiasm and three clarifying bullets.",
                "Plan a knowledge share on the feature nobody admits to understanding.",
                "Pair with analytics to translate dashboards into mortal speech.",
                "Collect status updates without summoning another mega-thread.",
                "Approve the icon set before UI sneaks in mysterious hieroglyphs.",
                "Prep the release checklist so launch day doesn't improvise.",
                "Ask security about the alert that keeps waving politely.",
                "Sync with support on the ticket queue before it becomes folklore.",
                "Send a kudos round-up so everyone remembers we're on the same team.",
            ];

            const createSeedItems = (slug, texts) =>
                texts.map((text, index) => ({
                    id: `${slug}-task-${index + 1}`,
                    text,
                    done: false,
                }));

            const PROTOTYPE_TASK_LIST = {
                id: "list-prototype",
                title: "Prototype Tasks",
                items: createSeedItems("prototype", PROTOTYPE_TASK_TEXTS),
            };

            const WEEKEND_PROJECT_LIST = {
                id: "list-weekend",
                title: "Weekend Projects",
                items: createSeedItems("weekend", WEEKEND_PROJECT_TEXTS),
            };

            const WORK_FOLLOWUP_LIST = {
                id: "list-work",
                title: "Work Follow-ups",
                items: createSeedItems("work", WORK_FOLLOWUP_TEXTS),
            };

            const SEED_LIST_CONFIGS = [
                PROTOTYPE_TASK_LIST,
                WEEKEND_PROJECT_LIST,
                WORK_FOLLOWUP_LIST,
            ];

            async function resetPersistentStorageIfNeeded() {
                const params = new URLSearchParams(window.location.search);
                if (!params.has("resetStorage")) {
                    return;
                }
                if (!("indexedDB" in window)) {
                    return;
                }
                await new Promise((resolve) => {
                    let settled = false;
                    const finish = () => {
                        if (settled) return;
                        settled = true;
                        resolve();
                    };
                    try {
                        const request = indexedDB.deleteDatabase(LISTS_DB_NAME);
                        request.onsuccess = finish;
                        request.onerror = finish;
                        request.onblocked = finish;
                    } catch (err) {
                        finish();
                    }
                });
                try {
                    window.localStorage?.clear?.();
                } catch (err) {
                    // ignore storage clearing errors
                }
            }

            async function ensureDemoData(repository, seedConfigs) {
                if (!repository || typeof repository.initialize !== "function") {
                    return false;
                }
                await repository.initialize();
                if (!Array.isArray(seedConfigs) || !seedConfigs.length) {
                    return false;
                }
                if (typeof repository.getListIds === "function" && repository.getListIds().length) {
                    return false;
                }
                let previousId = null;
                for (const config of seedConfigs) {
                    const listId =
                        typeof config.id === "string" && config.id.length
                            ? config.id
                            : `seed-${crypto.randomUUID()}`;
                    await repository.createList({
                        listId,
                        title: config.title,
                        items: Array.isArray(config.items) ? config.items : [],
                        afterId: previousId,
                    });
                    previousId = listId;
                }
                return true;
            }

            const cloneListState = (source) => ({
                title: typeof source?.title === "string" ? source.title : "",
                items: Array.isArray(source?.items)
                    ? source.items.map((item, index) => ({
                          id:
                              typeof item?.id === "string" && item.id.length
                                  ? item.id
                                  : `item-${index}`,
                          text: typeof item?.text === "string" ? item.text : "",
                          done: Boolean(item?.done),
                      }))
                    : [],
            });

            const generateItemId = () => `task-${crypto.randomUUID()}`;

            const generateListId = (prefix = "list") => `${prefix}-${crypto.randomUUID()}`;

            const LIST_ACTIONS = {
                setTitle: "list/setTitle",
                setItemDone: "list/setItemDone",
                updateItemText: "list/updateItemText",
                reorderItems: "list/reorderItems",
                replaceAll: "list/replaceAll",
                insertItem: "list/insertItem",
                removeItem: "list/removeItem",
            };

            // Centralizes allowed list mutations so the UI can ignore no-op actions and keep
            // state transitions predictable, which helps us skip redundant DOM work.
            const listReducer = (state = { title: "", items: [] }, action = {}) => {
                switch (action.type) {
                    case LIST_ACTIONS.setTitle: {
                        const nextTitle =
                            typeof action.payload?.title === "string"
                                ? action.payload.title
                                : state.title;
                        if (nextTitle === state.title) return state;
                        return { ...state, title: nextTitle };
                    }
                    case LIST_ACTIONS.setItemDone: {
                        const { id, done } = action.payload ?? {};
                        if (!id) return state;
                        const targetDone = Boolean(done);
                        let changed = false;
                        const nextItems = state.items.map((item) => {
                            if (item.id !== id) return item;
                            if (item.done === targetDone) return item;
                            changed = true;
                            return { ...item, done: targetDone };
                        });
                        return changed ? { ...state, items: nextItems } : state;
                    }
                    case LIST_ACTIONS.updateItemText: {
                        const { id, text } = action.payload ?? {};
                        if (!id || typeof text !== "string") return state;
                        const nextText = text;
                        let changed = false;
                        const nextItems = state.items.map((item) => {
                            if (item.id !== id) return item;
                            if (item.text === nextText) return item;
                            changed = true;
                            return { ...item, text: nextText };
                        });
                        return changed ? { ...state, items: nextItems } : state;
                    }
                    case LIST_ACTIONS.reorderItems: {
                        const order = Array.isArray(action.payload?.order)
                            ? action.payload.order
                            : null;
                        if (!order || !order.length) return state;
                        if (order.length !== state.items.length) return state;
                        const itemMap = new Map(state.items.map((item) => [item.id, item]));
                        const nextItems = order.map((id) => itemMap.get(id)).filter(Boolean);
                        if (nextItems.length !== state.items.length) return state;
                        const unchanged = nextItems.every(
                            (item, index) => item === state.items[index],
                        );
                        if (unchanged) return state;
                        return { ...state, items: nextItems };
                    }
                    case LIST_ACTIONS.insertItem: {
                        const { index, item } = action.payload ?? {};
                        if (!item || typeof item.id !== "string" || !item.id.length) return state;
                        if (state.items.some((existing) => existing.id === item.id)) return state;
                        const insertionIndex = Number.isInteger(index)
                            ? Math.max(0, Math.min(index, state.items.length))
                            : state.items.length;
                        const nextItem = {
                            id: item.id,
                            text: typeof item.text === "string" ? item.text : "",
                            done: Boolean(item.done),
                        };
                        const nextItems = state.items.slice();
                        nextItems.splice(insertionIndex, 0, nextItem);
                        return { ...state, items: nextItems };
                    }
                    case LIST_ACTIONS.removeItem: {
                        const { id } = action.payload ?? {};
                        if (typeof id !== "string" || !id.length) return state;
                        const nextItems = state.items.filter((item) => item.id !== id);
                        if (nextItems.length === state.items.length) return state;
                        return { ...state, items: nextItems };
                    }
                    case LIST_ACTIONS.replaceAll: {
                        const payload = action.payload;
                        if (!payload) return state;
                        const next = cloneListState(payload);
                        return next;
                    }
                    default:
                        return state;
                }
            };

            // Lightweight Redux-style store keeps the prototype dependency-free while still
            // allowing multiple collaborators (view, editor, drag) to react to one state source.
            const createStore = (reducer, preloadedState) => {
                let currentState =
                    typeof preloadedState === "undefined"
                        ? reducer(undefined, { type: "@@INIT" })
                        : reducer(preloadedState, { type: "@@INIT" });
                let listeners = new Set();

                return {
                    getState: () => currentState,
                    dispatch(action) {
                        const nextState = reducer(currentState, action);
                        if (nextState !== currentState) {
                            currentState = nextState;
                            listeners.forEach((fn) => fn());
                        }
                        return action;
                    },
                    subscribe(listener) {
                        if (typeof listener !== "function") return () => {};
                        listeners.add(listener);
                        return () => {
                            listeners.delete(listener);
                        };
                    },
                };
            };

            const escapeHTML = (str) =>
                str
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;")
                    .replace(/"/g, "&quot;")
                    .replace(/'/g, "&#39;");

            // Flattens overlapping highlight ranges so decoration stays deterministic when
            // multiple matchers target the same characters.
            const mergeRanges = (ranges) => {
                if (!ranges.length) return [];
                const sorted = ranges.slice().sort((a, b) => {
                    if (a.start !== b.start) return a.start - b.start;
                    if (a.priority !== b.priority) return a.priority - b.priority;
                    if (a.end !== b.end) return a.end - b.end;
                    return a.key.localeCompare(b.key);
                });
                const merged = [{ ...sorted[0] }];
                for (let i = 1; i < sorted.length; i++) {
                    const current = sorted[i];
                    const last = merged[merged.length - 1];
                    if (current.start <= last.end && current.key === last.key) {
                        last.end = Math.max(last.end, current.end);
                    } else {
                        merged.push({ ...current });
                    }
                }
                return merged;
            };

            // Produces highlighted markup only when every search token matches, so the UI
            // reinforces the filter semantics instead of showing partial hits.
            const buildDecoratedMarkup = (original, tokens, patternConfig) => {
                const haystack = original.toLowerCase();
                const ranges = [];
                const patterns = Array.isArray(patternConfig) ? patternConfig : [];
                let matchesAllTokens = true;

                tokens.forEach((token) => {
                    let searchIndex = 0;
                    let foundAny = false;
                    while (searchIndex <= haystack.length) {
                        const found = haystack.indexOf(token, searchIndex);
                        if (found === -1) break;
                        ranges.push({
                            start: found,
                            end: found + token.length,
                            priority: 1,
                            open: "<mark>",
                            close: "</mark>",
                            key: "mark",
                        });
                        searchIndex = found + token.length;
                        foundAny = true;
                    }
                    if (!foundAny) {
                        matchesAllTokens = false;
                    }
                });

                patterns.forEach((def) => {
                    const patternRegex = new RegExp(def.regexSource, def.regexFlags);
                    let match;
                    while ((match = patternRegex.exec(original)) !== null) {
                        if (!match[0].length) {
                            patternRegex.lastIndex += 1;
                            continue;
                        }
                        ranges.push({
                            start: match.index,
                            end: match.index + match[0].length,
                            priority: def.priority,
                            open: `<span class="${def.className}">`,
                            close: "</span>",
                            key: def.key,
                        });
                        if (!patternRegex.global) break;
                    }
                });

                if (!ranges.length) {
                    return { markup: null, matchesAllTokens };
                }

                const merged = mergeRanges(ranges);
                if (!merged.length) {
                    return { markup: null, matchesAllTokens };
                }

                const boundaries = new Set([0, original.length]);
                merged.forEach((range) => {
                    boundaries.add(range.start);
                    boundaries.add(range.end);
                });
                const sortedBoundaries = Array.from(boundaries).sort((a, b) => a - b);

                let result = "";
                for (let i = 0; i < sortedBoundaries.length - 1; i++) {
                    const start = sortedBoundaries[i];
                    const end = sortedBoundaries[i + 1];
                    if (start === end) continue;
                    let segment = escapeHTML(original.slice(start, end));
                    if (!segment) continue;
                    const covering = merged.filter(
                        (range) => range.start <= start && range.end >= end,
                    );
                    if (covering.length) {
                        covering.sort((a, b) => a.priority - b.priority);
                        for (let j = covering.length - 1; j >= 0; j--) {
                            const wrapper = covering[j];
                            segment = wrapper.open + segment + wrapper.close;
                        }
                    }
                    result += segment;
                }

                return { markup: result, matchesAllTokens };
            };

            const tokenizeSearchQuery = (query) => {
                if (typeof query !== "string") return [];
                return query
                    .trim()
                    .split(/\s+/)
                    .filter(Boolean)
                    .map((token) => token.toLowerCase());
            };

            const evaluateSearchEntry = ({
                originalText,
                tokens,
                patternConfig,
                showDone,
                isDone,
            }) => {
                const hiddenByCompletion = !showDone && isDone;
                if (hiddenByCompletion) {
                    return { hidden: true, markup: null };
                }

                const { markup, matchesAllTokens } = buildDecoratedMarkup(
                    originalText,
                    tokens,
                    patternConfig,
                );
                if (tokens.length > 0 && !matchesAllTokens) {
                    return { hidden: true, markup: null };
                }

                return { hidden: false, markup };
            };

            const escapeSelectorId = (value) => {
                if (typeof value !== "string") return "";
                return value.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
            };

            // EditController queues follow-up edits so caret placement survives rerenders that
            // happen between an action (merge, move) and the next paint.
            class EditController {
                constructor({ getListElement, getInlineEditor }) {
                    this.getListElement =
                        typeof getListElement === "function" ? getListElement : () => null;
                    this.getInlineEditor =
                        typeof getInlineEditor === "function" ? getInlineEditor : () => null;
                    this.pendingItemId = null;
                    this.pendingCaret = null;
                }

                queue(itemId, caretPreference = null) {
                    if (typeof itemId === "string" && itemId.length) {
                        this.pendingItemId = itemId;
                        this.pendingCaret = caretPreference ?? null;
                    }
                }

                clear() {
                    this.pendingItemId = null;
                    this.pendingCaret = null;
                }

                hasPending() {
                    return typeof this.pendingItemId === "string" && this.pendingItemId.length > 0;
                }

                isPendingItem(itemId) {
                    if (!this.hasPending()) return false;
                    return this.pendingItemId === itemId;
                }

                getPendingEdit() {
                    if (!this.hasPending()) return null;
                    return {
                        itemId: this.pendingItemId,
                        caret: this.pendingCaret,
                    };
                }

                getForceVisibleIds() {
                    if (!this.hasPending()) return null;
                    return new Set([this.pendingItemId]);
                }

                applyPendingEdit() {
                    if (!this.hasPending()) return false;
                    const listEl = this.getListElement();
                    const inlineEditor = this.getInlineEditor();
                    if (!listEl || !inlineEditor) return false;

                    const selectorId = escapeSelectorId(this.pendingItemId);
                    const targetLi = listEl.querySelector(`li[data-item-id="${selectorId}"]`);
                    const textEl = targetLi?.querySelector(".text") ?? null;
                    if (!textEl) {
                        return false;
                    }

                    inlineEditor.startEditing(textEl, null, this.pendingCaret);
                    this.clear();
                    return true;
                }
            }

            // TaskListView keeps DOM reconciliation separate from state changes so we can reuse
            // focused nodes and avoid churn when the reducer reorders items.
            class TaskListView {
                constructor({ getListElement }) {
                    this.getListElement =
                        typeof getListElement === "function" ? getListElement : () => null;
                }

                captureFocus() {
                    const listEl = this.getListElement();
                    if (!listEl) return null;
                    const activeElement = document.activeElement;
                    if (!activeElement || !listEl.contains(activeElement)) return null;
                    const activeLi = activeElement.closest("li");
                    if (!activeLi?.dataset?.itemId) return null;
                    const role = activeElement.classList.contains("done-toggle")
                        ? "toggle"
                        : activeElement.classList.contains("text")
                          ? "text"
                          : null;
                    return role ? { itemId: activeLi.dataset.itemId, role } : null;
                }

                syncItems(items, { createItem, updateItem }) {
                    const listEl = this.getListElement();
                    if (!listEl || !Array.isArray(items)) return;
                    const existingNodes = Array.from(listEl.children).filter(
                        (li) => !li.classList.contains("placeholder"),
                    );
                    const byId = new Map(existingNodes.map((li) => [li.dataset.itemId, li]));
                    const usedNodes = new Set();
                    let previous = null;

                    const nextNonPlaceholder = (node) => {
                        while (node && node.classList?.contains("placeholder")) {
                            node = node.nextSibling;
                        }
                        return node;
                    };

                    items.forEach((item) => {
                        let li = byId.get(item.id);
                        if (!li) {
                            li = createItem(item);
                        } else {
                            updateItem(li, item);
                        }
                        usedNodes.add(li);
                        const desired = previous
                            ? nextNonPlaceholder(previous.nextSibling)
                            : nextNonPlaceholder(listEl.firstChild);
                        if (li !== desired) {
                            listEl.insertBefore(li, desired || null);
                        }
                        previous = li;
                    });

                    existingNodes.forEach((li) => {
                        if (!usedNodes.has(li)) {
                            li.remove();
                        }
                    });
                }

                restoreFocus(preservedFocus, { skip } = {}) {
                    if (skip || !preservedFocus) return;
                    const listEl = this.getListElement();
                    if (!listEl) return;
                    const selectorId = escapeSelectorId(preservedFocus.itemId);
                    const targetLi = listEl.querySelector(`li[data-item-id="${selectorId}"]`);
                    if (!targetLi) return;
                    const focusTarget =
                        preservedFocus.role === "toggle"
                            ? targetLi.querySelector(".done-toggle")
                            : preservedFocus.role === "text"
                              ? targetLi.querySelector(".text")
                              : null;
                    focusTarget?.focus();
                }
            }

            // Custom element binds the store, view, and behaviors together so the prototype
            // remains drop-in embeddable without a framework runtime.
            class A4TaskList extends HTMLElement {
                constructor() {
                    super();
                    this.listEl = null;
                    this.dragBehavior = null;
                    this.inlineEditor = null;
                    this.headerEl = null;
                    this.titleEl = null;
                    this.searchInput = null;
                    this.addButton = null;
                    this.showDoneCheckbox = null;
                    this.searchTimer = null;
                    this.searchQuery = "";
                    this.showDone = false;
                    this.store = null;
                    this.unsubscribe = null;
                    this.suppressNameSync = false;
                    this._initialState = null;
                    this.patternConfig = this.normalizePatternDefs([
                        {
                            regex: /@[A-Za-z0-9_]+/g,
                            className: "task-token-mention",
                            priority: 2,
                        },
                        {
                            regex: /#[A-Za-z0-9_]+/g,
                            className: "task-token-tag",
                            priority: 2,
                        },
                    ]);

                    this.listIdentifier = this.dataset.listId ?? null;
                    this.lastFocusedItemId = null;
                    this.lastReportedMatches = null;
                    this.lastReportedTotal = null;
                    this.lastReportedQuery = "";
                    this.lastReportedTitle = null;
                    this.emptyStateEl = null;
                    this.isTitleEditing = false;
                    this.titleOriginalValue = "";
                    this.openActionsItem = null;
                    this.touchGestureState = new Map();

                    this.handleSearchInput = this.handleSearchInput.bind(this);
                    this.handleSearchKeyDown = this.handleSearchKeyDown.bind(this);
                    this.handleSearchClear = this.handleSearchClear.bind(this);
                    this.handleItemBlur = this.handleItemBlur.bind(this);
                    this.handleToggle = this.handleToggle.bind(this);
                    this.handleStoreChange = this.handleStoreChange.bind(this);
                    this.handleEditCommit = this.handleEditCommit.bind(this);
                    this.handleEditSplit = this.handleEditSplit.bind(this);
                    this.handleEditMerge = this.handleEditMerge.bind(this);
                    this.handleEditRemove = this.handleEditRemove.bind(this);
                    this.handleEditMove = this.handleEditMove.bind(this);
                    this.handleAddButtonClick = this.handleAddButtonClick.bind(this);
                    this.handleShowDoneChange = this.handleShowDoneChange.bind(this);
                    this.scheduleReorderUpdate = this.scheduleReorderUpdate.bind(this);
                    this.handleMoveButtonClick = this.handleMoveButtonClick.bind(this);
                    this.handleDeleteButtonClick = this.handleDeleteButtonClick.bind(this);
                    this.handleActionToggleClick = this.handleActionToggleClick.bind(this);
                    this.handleItemKeyDown = this.handleItemKeyDown.bind(this);
                    this.handleFocusIn = this.handleFocusIn.bind(this);
                    this.handleListDragStart = this.handleListDragStart.bind(this);
                    this.handleTitleClick = this.handleTitleClick.bind(this);
                    this.handleTitleKeyDown = this.handleTitleKeyDown.bind(this);
                    this.handleTitleBlur = this.handleTitleBlur.bind(this);
                    this.handleDocumentPointerDown =
                        this.handleDocumentPointerDown.bind(this);
                    this.handleTouchGestureStart = this.handleTouchGestureStart.bind(this);
                    this.handleTouchGestureEnd = this.handleTouchGestureEnd.bind(this);
                    this.handleTouchGestureCancel =
                        this.handleTouchGestureCancel.bind(this);

                    this.editController = new EditController({
                        getListElement: () => this.listEl,
                        getInlineEditor: () => this.inlineEditor,
                    });
                    this.view = new TaskListView({
                        getListElement: () => this.listEl,
                    });
                    this.pendingEditFlushRequested = false;
                    this._repository = null;
                    this.repositoryUnsubscribe = null;
                }

                static get observedAttributes() {
                    return ["name"];
                }

                get initialState() {
                    return this._initialState;
                }

                set initialState(value) {
                    this.applyRepositoryState(value ?? { title: "", items: [] });
                }

                connectedCallback() {
                    this.ensureList();
                    if (!this.listEl) return;

                    this.ensureHeader();
                    if (this.searchInput) {
                        this.searchInput.value = this.searchQuery;
                    }
                    if (this.showDoneCheckbox) {
                        this.showDoneCheckbox.checked = this.showDone;
                    }

                    this.initializeStore();
                    this.refreshRepositorySubscription();

                    if (!this.dragBehavior) {
                        this.dragBehavior = new DraggableBehavior(this.listEl, {
                            handleClass: "handle",
                            onReorder: (fromIndex, toIndex) => {
                                const detail = { fromIndex, toIndex };
                                this.listEl.dispatchEvent(new CustomEvent("reorder", { detail }));
                                this.dispatchEvent(
                                    new CustomEvent("reorder", {
                                        detail,
                                        bubbles: true,
                                        composed: true,
                                    }),
                                );
                                this.scheduleReorderUpdate();
                            },
                            animator: new FlipAnimator(),
                        });
                    }
                    this.dragBehavior.enable();

                    this.ensureInlineEditor();

                    this.listEl.removeEventListener("blur", this.handleItemBlur, true);
                    this.listEl.addEventListener("blur", this.handleItemBlur, true);
                    this.listEl.removeEventListener("focusin", this.handleFocusIn);
                    this.listEl.addEventListener("focusin", this.handleFocusIn);
                    this.listEl.removeEventListener("dragstart", this.handleListDragStart);
                    this.listEl.addEventListener("dragstart", this.handleListDragStart);
                    this.listEl.removeEventListener(
                        "touchstart",
                        this.handleTouchGestureStart,
                    );
                    this.listEl.addEventListener("touchstart", this.handleTouchGestureStart, {
                        passive: true,
                    });
                    this.listEl.removeEventListener("touchend", this.handleTouchGestureEnd);
                    this.listEl.addEventListener("touchend", this.handleTouchGestureEnd, {
                        passive: true,
                    });
                    this.listEl.removeEventListener(
                        "touchcancel",
                        this.handleTouchGestureCancel,
                    );
                    this.listEl.addEventListener(
                        "touchcancel",
                        this.handleTouchGestureCancel,
                        {
                            passive: true,
                        },
                    );
                    if (this.listIdentifier) {
                        this.dataset.listId = this.listIdentifier;
                    }
                    this.performSearch(this.searchQuery);
                    document.removeEventListener(
                        "pointerdown",
                        this.handleDocumentPointerDown,
                    );
                    document.addEventListener("pointerdown", this.handleDocumentPointerDown);
                }

                initializeStore() {
                    const baseState = this.buildInitialState();
                    if (!this.store) {
                        this.store = createStore(listReducer, baseState);
                    } else if (baseState) {
                        this.store.dispatch({
                            type: LIST_ACTIONS.replaceAll,
                            payload: baseState,
                        });
                    }
                    if (this.store && !this.unsubscribe) {
                        this.unsubscribe = this.store.subscribe(this.handleStoreChange);
                    }
                    if (this.store) {
                        this.handleStoreChange();
                    }
                }

                refreshRepositorySubscription() {
                    this.repositoryUnsubscribe?.();
                    this.repositoryUnsubscribe = null;
                    if (!this._repository || !this.listId) {
                        return;
                    }
                    if (
                        typeof this._repository.isInitialized === "function" &&
                        !this._repository.isInitialized()
                    ) {
                        const maybePromise = this._repository.initialize?.();
                        if (maybePromise && typeof maybePromise.then === "function") {
                            maybePromise.then(() => {
                                if (this._repository && this.listId) {
                                    this.refreshRepositorySubscription();
                                }
                            });
                        }
                        return;
                    }
                    const currentState = this._repository.getListState(this.listId);
                    if (currentState) {
                        this.applyRepositoryState(currentState);
                    }
                    this.repositoryUnsubscribe = this._repository.subscribeList(
                        this.listId,
                        (state) => this.applyRepositoryState(state),
                        { emitCurrent: false },
                    );
                }

                applyRepositoryState(state) {
                    const next = cloneListState(state);
                    this._initialState = next;
                    if (this.store) {
                        this.store.dispatch({
                            type: LIST_ACTIONS.replaceAll,
                            payload: next,
                        });
                        return;
                    }
                    if (this.isConnected) {
                        this.initializeStore();
                    }
                }

                syncFromRepository() {
                    if (!this._repository || !this.listId) return;
                    const latest = this._repository.getListState(this.listId);
                    if (latest) {
                        this.applyRepositoryState(latest);
                    }
                }

                runRepositoryOperation(promise) {
                    if (!promise || typeof promise.then !== "function") return;
                    promise
                        .then(() => {
                            this.syncFromRepository();
                        })
                        .catch(() => {});
                }

                buildInitialState() {
                    const fallback = {
                        title: this.getAttribute("name") ?? "",
                        items: [],
                    };
                    const source = this._initialState ?? fallback;
                    const baseState = cloneListState(source);
                    const attrTitle = this.getAttribute("name");
                    if (typeof attrTitle === "string" && attrTitle.length) {
                        baseState.title = attrTitle;
                    }
                    return baseState;
                }

                disconnectedCallback() {
                    this.dragBehavior?.destroy();
                    this.dragBehavior = null;
                    this.listEl?.removeEventListener("blur", this.handleItemBlur, true);
                    this.listEl?.removeEventListener("focusin", this.handleFocusIn);
                    this.listEl?.removeEventListener("dragstart", this.handleListDragStart);
                    this.listEl?.removeEventListener(
                        "touchstart",
                        this.handleTouchGestureStart,
                    );
                    this.listEl?.removeEventListener("touchend", this.handleTouchGestureEnd);
                    this.listEl?.removeEventListener(
                        "touchcancel",
                        this.handleTouchGestureCancel,
                    );
                    if (this.searchInput) {
                        this.searchInput.removeEventListener("input", this.handleSearchInput);
                        this.searchInput.removeEventListener("keydown", this.handleSearchKeyDown);
                    }
                    clearTimeout(this.searchTimer);
                    this.searchTimer = null;
                    this.repositoryUnsubscribe?.();
                    this.repositoryUnsubscribe = null;
                    this.classList.remove("tasklist-no-matches");
                    document.removeEventListener(
                        "pointerdown",
                        this.handleDocumentPointerDown,
                    );
                    this.touchGestureState.clear();
                    this.openActionsItem = null;
                }

                dispose() {
                    this.unsubscribe?.();
                    this.unsubscribe = null;
                    this.store = null;
                    this.inlineEditor?.destroy();
                    this.inlineEditor = null;
                    this.repositoryUnsubscribe?.();
                    this.repositoryUnsubscribe = null;
                }

                attributeChangedCallback(name, oldValue, newValue) {
                    if (name === "name" && oldValue !== newValue) {
                        if (this.suppressNameSync) return;
                        const nextTitle = typeof newValue === "string" ? newValue : "";
                        if (this._repository && this.listId) {
                            const promise = this._repository.renameList(this.listId, nextTitle);
                            this.runRepositoryOperation(promise);
                        } else if (this.store) {
                            this.store.dispatch({
                                type: LIST_ACTIONS.setTitle,
                                payload: { title: nextTitle },
                            });
                        } else {
                            this.syncTitle();
                        }
                    }
                }

                ensureList() {
                    if (this.listEl && this.contains(this.listEl)) return;

                    let list = this.querySelector("ol.tasklist");
                    const existingItems = Array.from(this.querySelectorAll(":scope > li"));
                    if (!list) {
                        render(
                            html`
                                <ol class="tasklist"></ol>
                            `,
                            this,
                        );
                        list = this.querySelector("ol.tasklist");
                    }
                    if (list && existingItems.length) {
                        existingItems.forEach((li) => list.appendChild(li));
                    }
                    this.listEl = list;

                    if (!this.emptyStateEl || !this.contains(this.emptyStateEl)) {
                        const emptyTemplate = html`
                            <div class="tasklist-empty" hidden>No matching items</div>
                        `;
                        if (this.listEl?.nextSibling) {
                            const fragment = document.createElement("div");
                            render(emptyTemplate, fragment);
                            const emptyElement = fragment.firstElementChild;
                            if (emptyElement) {
                                this.insertBefore(emptyElement, this.listEl.nextSibling);
                                this.emptyStateEl = emptyElement;
                            }
                        } else {
                            render(emptyTemplate, this);
                            this.emptyStateEl = this.querySelector(".tasklist-empty");
                        }
                    }
                }

                ensureHeader() {
                    if (!this.headerEl || !this.contains(this.headerEl)) {
                        const header = document.createElement("div");
                        header.className = "tasklist-header";
                        if (this.listEl && this.contains(this.listEl)) {
                            this.insertBefore(header, this.listEl);
                        } else {
                            this.appendChild(header);
                        }
                        this.headerEl = header;
                    }

                    const currentTitle = this.getAttribute("name") ?? "";
                    const currentSearch =
                        this.searchInput?.value ?? this.searchQuery ?? "";
                    const showDoneChecked =
                        typeof this.showDone === "boolean" ? this.showDone : false;

                    render(
                        html`
                            <h2
                                class="tasklist-title"
                                tabindex="0"
                                title="Click to rename"
                            >
                                ${currentTitle}
                            </h2>
                            <div class="tasklist-controls">
                                <input
                                    type="search"
                                    class="tasklist-search-input"
                                    placeholder="Search tasks..."
                                    aria-label="Search tasks"
                                    .value=${currentSearch}
                                />
                                <label class="tasklist-show-done">
                                    <input
                                        type="checkbox"
                                        class="tasklist-show-done-toggle"
                                        ?checked=${showDoneChecked}
                                        @change=${this.handleShowDoneChange}
                                    />
                                    <span>Show done</span>
                                </label>
                                <button
                                    type="button"
                                    class="iconlabel"
                                    aria-label="Add task"
                                    data-role="tasklist-add"
                                >
                                    <svg
                                        viewBox="0 0 16 16"
                                        aria-hidden="true"
                                        focusable="false"
                                    >
                                        <path
                                            fill="currentColor"
                                            d="M7 1h2v6h6v2H9v6H7V9H1V7h6z"
                                        ></path>
                                    </svg>
                                    <span>Add</span>
                                </button>
                            </div>
                        `,
                        this.headerEl,
                    );

                    this.titleEl =
                        this.headerEl.querySelector(".tasklist-title") ?? null;
                    this.searchInput =
                        this.headerEl.querySelector(".tasklist-search-input") ?? null;
                    this.showDoneCheckbox =
                        this.headerEl.querySelector(".tasklist-show-done-toggle") ?? null;
                    this.addButton =
                        this.headerEl.querySelector("[data-role='tasklist-add']") ?? null;

                    if (this.titleEl) {
                        this.titleEl.setAttribute("tabindex", "0");
                        this.titleEl.setAttribute("title", "Click to rename");
                        this.titleEl.removeEventListener("click", this.handleTitleClick);
                        this.titleEl.addEventListener("click", this.handleTitleClick);
                        this.titleEl.removeEventListener("keydown", this.handleTitleKeyDown);
                        this.titleEl.addEventListener("keydown", this.handleTitleKeyDown);
                    }

                    if (this.searchInput) {
                        this.searchInput.removeEventListener("input", this.handleSearchInput);
                        this.searchInput.removeEventListener("keydown", this.handleSearchKeyDown);
                        this.searchInput.addEventListener("input", this.handleSearchInput);
                        this.searchInput.addEventListener("keydown", this.handleSearchKeyDown);
                    }
                    if (this.addButton) {
                        this.addButton.removeEventListener("click", this.handleAddButtonClick);
                        this.addButton.addEventListener("click", this.handleAddButtonClick);
                    }
                }

                ensureInlineEditor() {
                    if (this.inlineEditor || !this.listEl) {
                        return this.inlineEditor;
                    }
                    this.inlineEditor = new InlineTextEditor(this.listEl, {
                        onCommit: this.handleEditCommit,
                        onSplit: this.handleEditSplit,
                        onMerge: this.handleEditMerge,
                        onRemove: this.handleEditRemove,
                        onMove: this.handleEditMove,
                    });
                    return this.inlineEditor;
                }

                startTitleEditing() {
                    if (!this.titleEl || this.isTitleEditing) return;
                    this.isTitleEditing = true;
                    this.titleOriginalValue = this.titleEl.textContent ?? "";
                    this.titleEl.classList.add("is-editing");
                    this.titleEl.setAttribute("contenteditable", "true");
                    this.titleEl.setAttribute("spellcheck", "false");
                    this.titleEl.setAttribute("role", "textbox");
                    this.titleEl.setAttribute("aria-multiline", "false");
                    this.titleEl.setAttribute("aria-label", "List title");
                    this.titleEl.addEventListener("blur", this.handleTitleBlur);
                    this.titleEl.focus();
                    const selection = document.getSelection();
                    if (selection) {
                        const range = document.createRange();
                        range.selectNodeContents(this.titleEl);
                        selection.removeAllRanges();
                        selection.addRange(range);
                    }
                }

                finishTitleEditing() {
                    if (!this.titleEl) return;
                    this.titleEl.classList.remove("is-editing");
                    this.titleEl.removeAttribute("contenteditable");
                    this.titleEl.removeAttribute("spellcheck");
                    this.titleEl.removeAttribute("role");
                    this.titleEl.removeAttribute("aria-multiline");
                    this.titleEl.removeAttribute("aria-label");
                    this.titleEl.removeEventListener("blur", this.handleTitleBlur);
                    this.isTitleEditing = false;
                    this.titleOriginalValue = "";
                }

                commitTitleEditing({ restoreFocus = true } = {}) {
                    if (!this.titleEl || !this.isTitleEditing) return;
                    const rawValue = this.titleEl.textContent ?? "";
                    const trimmed = rawValue.trim();
                    const previousValue = this.titleOriginalValue ?? "";

                    if (!trimmed.length) {
                        this.titleEl.textContent = previousValue;
                        this.finishTitleEditing();
                        if (restoreFocus) {
                            this.titleEl.focus();
                        }
                        return;
                    }

                    this.titleEl.textContent = trimmed;
                    this.finishTitleEditing();

                    if (trimmed === previousValue) {
                        if (restoreFocus) {
                            this.titleEl.focus();
                        }
                        return;
                    }

                    if (this.store) {
                        this.store.dispatch({
                            type: LIST_ACTIONS.setTitle,
                            payload: { title: trimmed },
                        });
                    } else {
                        this.setAttribute("name", trimmed);
                        this.syncTitle();
                    }

                    if (this._repository && this.listId) {
                        const promise = this._repository.renameList(this.listId, trimmed);
                        this.runRepositoryOperation(promise);
                    }

                    this.dispatchEvent(
                        new CustomEvent("titlechange", {
                            detail: { title: trimmed },
                            bubbles: true,
                            composed: true,
                        }),
                    );

                    if (restoreFocus) {
                        this.titleEl.focus();
                    }
                }

                cancelTitleEditing({ restoreFocus = true } = {}) {
                    if (!this.titleEl || !this.isTitleEditing) return;
                    const previousValue = this.titleOriginalValue ?? "";
                    this.titleEl.textContent = previousValue;
                    this.finishTitleEditing();
                    if (restoreFocus) {
                        this.titleEl.focus();
                    }
                }

                handleTitleClick() {
                    if (this.isTitleEditing) return;
                    this.startTitleEditing();
                }

                handleTitleKeyDown(event) {
                    if (!this.titleEl) return;
                    if (this.isTitleEditing) {
                        if (event.key === "Enter") {
                            event.preventDefault();
                            this.commitTitleEditing();
                        } else if (event.key === "Escape") {
                            event.preventDefault();
                            this.cancelTitleEditing();
                        }
                        return;
                    }

                    if (event.key === "Enter" || event.key === " " || event.key === "Spacebar") {
                        event.preventDefault();
                        this.startTitleEditing();
                    }
                }

                handleTitleBlur() {
                    if (!this.isTitleEditing) return;
                    this.commitTitleEditing({ restoreFocus: false });
                }

                syncTitle() {
                    if (!this.titleEl || this.isTitleEditing) return;
                    const value = this.getAttribute("name");
                    this.titleEl.textContent = value ?? "";
                }

                normalizePatternDefs(defs) {
                    // Accepts both literal regexes and plain objects so embedding pages can
                    // configure highlights without worrying about flag safety or class naming.
                    if (!Array.isArray(defs)) return [];
                    const normalized = [];
                    defs.forEach((def) => {
                        if (!def) return;
                        let { regex, className, priority } = def;
                        if (typeof regex === "string") {
                            try {
                                regex = new RegExp(regex, "g");
                            } catch (err) {
                                return;
                            }
                        } else if (regex instanceof RegExp) {
                            const flags = regex.flags.includes("g")
                                ? regex.flags
                                : regex.flags + "g";
                            regex = new RegExp(regex.source, flags);
                        } else {
                            return;
                        }

                        const safeClass =
                            typeof className === "string" && className.trim().length
                                ? className.trim()
                                : "task-token";
                        const prio = Number.isFinite(priority) ? priority : 2;
                        normalized.push({
                            regexSource: regex.source,
                            regexFlags: regex.flags,
                            className: safeClass,
                            priority: prio,
                            key: `pattern:${safeClass}`,
                        });
                    });
                    return normalized;
                }

                setPatternHighlighters(defs) {
                    this.patternConfig = this.normalizePatternDefs(defs);
                    this.performSearch(this.searchQuery);
                }

                get patternHighlighters() {
                    return this.patternConfig.map((def) => ({
                        regex: new RegExp(def.regexSource, def.regexFlags),
                        className: def.className,
                        priority: def.priority,
                    }));
                }

                set patternHighlighters(defs) {
                    this.setPatternHighlighters(defs);
                }

                handleSearchInput() {
                    if (!this.searchInput) return;
                    const value = this.searchInput.value;
                    clearTimeout(this.searchTimer);
                    this.searchTimer = setTimeout(() => {
                        this.performSearch(value);
                        this.searchTimer = null;
                    }, 120);
                }

                handleSearchKeyDown(e) {
                    if (e.key === "Escape") {
                        e.preventDefault();
                        this.clearSearch();
                        this.searchInput?.focus();
                    }
                }

                handleSearchClear() {
                    this.clearSearch();
                    this.searchInput?.focus();
                }

                handleShowDoneChange(e) {
                    const isChecked = Boolean(e?.target?.checked);
                    if (this.showDone === isChecked) return;
                    this.showDone = isChecked;
                    this.performSearch(this.searchQuery);
                }

                clearSearch() {
                    clearTimeout(this.searchTimer);
                    this.searchTimer = null;
                    if (this.searchInput) {
                        this.searchInput.value = "";
                    }
                    this.performSearch("");
                }

                handleAddButtonClick() {
                    if (!this.store) return;
                    this.ensureInlineEditor();
                    if (this.searchQuery) {
                        this.clearSearch();
                    }
                    const stateBefore = this.store.getState();
                    const firstItem =
                        Array.isArray(stateBefore?.items) && stateBefore.items.length
                            ? stateBefore.items[0].id
                            : null;
                    const newId = generateItemId();
                    this.editController.queue(newId, "end");
                    this.schedulePendingEditFlush();
                    this.store.dispatch({
                        type: LIST_ACTIONS.insertItem,
                        payload: {
                            index: 0,
                            item: { id: newId, text: "", done: false },
                        },
                    });
                    this.handleStoreChange();
                    if (!this.focusItemImmediately(newId, "end")) {
                        this.editController.applyPendingEdit();
                    }
                    if (this._repository && this.listId) {
                        const promise = this._repository.insertTask(this.listId, {
                            itemId: newId,
                            text: "",
                            done: false,
                            beforeId: firstItem ?? undefined,
                        });
                        this.runRepositoryOperation(promise);
                    }
                }

                handleEditSplit({ element, beforeText, afterText }) {
                    if (!element || !this.store) return;
                    const li = element.closest("li");
                    const id = li?.dataset?.itemId;
                    if (!id) return;

                    const state = this.store.getState();
                    const currentIndex = state.items.findIndex((item) => item.id === id);
                    if (currentIndex === -1) return;
                    const nextItemId = state.items[currentIndex + 1]?.id ?? null;

                    const newId = generateItemId();
                    this.editController.queue(newId, "start");
                    this.schedulePendingEditFlush();
                    if (typeof beforeText === "string") {
                        this.store.dispatch({
                            type: LIST_ACTIONS.updateItemText,
                            payload: { id, text: beforeText },
                        });
                    }

                    this.store.dispatch({
                        type: LIST_ACTIONS.insertItem,
                        payload: {
                            index: currentIndex + 1,
                            item: {
                                id: newId,
                                text: typeof afterText === "string" ? afterText : "",
                                done: false,
                            },
                        },
                    });
                    this.handleStoreChange();
                    if (!this.focusItemImmediately(newId, "start")) {
                        this.editController.applyPendingEdit();
                    }
                    if (this._repository && this.listId) {
                        const promise = (async () => {
                            if (typeof beforeText === "string") {
                                await this._repository.updateTask(this.listId, id, {
                                    text: beforeText,
                                });
                            }
                            await this._repository.insertTask(this.listId, {
                                itemId: newId,
                                text: typeof afterText === "string" ? afterText : "",
                                done: false,
                                afterId: id,
                                beforeId: nextItemId ?? undefined,
                            });
                        })();
                        this.runRepositoryOperation(promise);
                    }
                }

                // Re-stitches adjacent tasks on Backspace so users can treat the list like a text editor without losing content.
                handleEditMerge({ currentItemId, previousItemId, currentText, selectionStart }) {
                    if (!this.store || !currentItemId || !previousItemId) return false;

                    const state = this.store.getState();
                    const items = Array.isArray(state?.items) ? state.items : [];
                    const currentIndex = items.findIndex((item) => item.id === currentItemId);
                    if (currentIndex <= 0) return false;

                    const previousIndex = currentIndex - 1;
                    const previousItem = items[previousIndex];
                    if (!previousItem || previousItem.id !== previousItemId) return false;

                    const prevText = typeof previousItem.text === "string" ? previousItem.text : "";
                    const currentTextValue = typeof currentText === "string" ? currentText : "";
                    const mergedText = prevText + currentTextValue;

                    const mergeOffset =
                        prevText.length +
                        (typeof selectionStart === "number"
                            ? Math.max(0, Math.min(selectionStart, currentTextValue.length))
                            : 0);

                    this.editController.queue(previousItem.id, {
                        type: "offset",
                        value: mergeOffset,
                    });
                    this.schedulePendingEditFlush();

                    this.store.dispatch({
                        type: LIST_ACTIONS.updateItemText,
                        payload: { id: previousItem.id, text: mergedText },
                    });
                    this.store.dispatch({
                        type: LIST_ACTIONS.removeItem,
                        payload: { id: currentItemId },
                    });
                    this.handleStoreChange();
                    if (
                        !this.focusItemImmediately(previousItem.id, {
                            type: "offset",
                            value: mergeOffset,
                        })
                    ) {
                        this.editController.applyPendingEdit();
                    }

                    if (this._repository && this.listId) {
                        const promise = (async () => {
                            await this._repository.updateTask(this.listId, previousItem.id, {
                                text: mergedText,
                            });
                            await this._repository.removeTask(this.listId, currentItemId);
                        })();
                        this.runRepositoryOperation(promise);
                    }

                    return true;
                }

                // Redirects focus when a task is deleted so keyboard users land on a sensible neighbor instead of losing their place.
                handleEditRemove({ element }) {
                    if (!element || !this.store) return;
                    const li = element.closest("li");
                    const id = li?.dataset?.itemId;
                    if (!id) return;

                    const state = this.store.getState();
                    const items = state?.items ?? [];
                    const currentIndex = items.findIndex((item) => item.id === id);
                    if (currentIndex === -1) return;

                    const nextItem = items[currentIndex + 1] ?? items[currentIndex - 1] ?? null;
                    const focusTargetId = nextItem?.id ?? null;
                    if (focusTargetId) {
                        this.editController.queue(focusTargetId, "end");
                        this.schedulePendingEditFlush();
                    } else {
                        this.editController.clear();
                    }

                    this.closeActionsForItem(li);

                    this.store.dispatch({
                        type: LIST_ACTIONS.removeItem,
                        payload: { id },
                    });
                    this.handleStoreChange();
                    if (!focusTargetId || !this.focusItemImmediately(focusTargetId, "end")) {
                        this.editController.applyPendingEdit();
                    }

                    if (this._repository && this.listId) {
                        const promise = this._repository.removeTask(this.listId, id);
                        this.runRepositoryOperation(promise);
                    }
                }

                // Supports ctrl/cmd + arrow reordering while preserving caret placement, matching expectations from native outliners.
                handleEditMove({ element, direction, selectionStart }) {
                    if (!element || !this.store) return;
                    const li = element.closest("li");
                    const id = li?.dataset?.itemId;
                    if (!id) return;

                    const state = this.store.getState();
                    const items = Array.isArray(state?.items) ? state.items : [];
                    const fromIndex = items.findIndex((item) => item.id === id);
                    if (fromIndex === -1) return;
                    const delta = direction === "down" ? 1 : -1;
                    const toIndex = fromIndex + delta;
                    if (toIndex < 0 || toIndex >= items.length) return;

                    const order = items.map((item) => item.id);
                    const [moved] = order.splice(fromIndex, 1);
                    order.splice(toIndex, 0, moved);

                    const caretOffset =
                        typeof selectionStart === "number" ? Math.max(0, selectionStart) : 0;
                    this.editController.queue(id, {
                        type: "offset",
                        value: caretOffset,
                    });
                    this.schedulePendingEditFlush();
                    this.inlineEditor?.finishEditing(element, true);

                    this.store.dispatch({
                        type: LIST_ACTIONS.reorderItems,
                        payload: { order },
                    });
                    this.handleStoreChange();
                    if (
                        !this.focusItemImmediately(id, {
                            type: "offset",
                            value: caretOffset,
                        })
                    ) {
                        this.editController.applyPendingEdit();
                    }

                    if (this._repository && this.listId) {
                        const beforeNeighbor = order[toIndex - 1] ?? null;
                        const afterNeighbor = order[toIndex + 1] ?? null;
                        const promise = this._repository.moveTaskWithinList(this.listId, id, {
                            afterId: beforeNeighbor ?? undefined,
                            beforeId: afterNeighbor ?? undefined,
                        });
                        this.runRepositoryOperation(promise);
                    }
                }

                handleStoreChange() {
                    if (!this.store) return;
                    this.renderFromState(this.store.getState());
                }

                schedulePendingEditFlush() {
                    if (this.pendingEditFlushRequested) return;
                    this.pendingEditFlushRequested = true;
                    const scheduleFlush = (cb) => {
                        if (typeof requestAnimationFrame === "function") {
                            requestAnimationFrame(() => cb());
                        } else if (typeof queueMicrotask === "function") {
                            queueMicrotask(cb);
                        } else {
                            Promise.resolve().then(cb);
                        }
                    };
                    scheduleFlush(() => {
                        this.pendingEditFlushRequested = false;
                        if (!this.editController?.hasPending()) {
                            return;
                        }
                        this.editController.applyPendingEdit();
                    });
                }

                focusItemImmediately(itemId, caretPreference = null) {
                    if (!this.listEl || !this.inlineEditor) {
                        return false;
                    }
                    const selectorId = escapeSelectorId(itemId ?? "");
                    if (!selectorId) return false;
                    const targetLi = this.listEl.querySelector(`li[data-item-id="${selectorId}"]`);
                    const textEl = targetLi?.querySelector(".text") ?? null;
                    if (!textEl) {
                        return false;
                    }
                    this.inlineEditor.startEditing(textEl, null, caretPreference);
                    this.editController.clear();
                    return true;
                }

                // Acts as the single render pass so focus management and search updates happen in a predictable order after each state change.
                renderFromState(state) {
                    if (!this.listEl || !state) return;

                    const preservedFocus = this.view.captureFocus();

                    this.view.syncItems(state.items, {
                        createItem: (item) => this.createItemElement(item),
                        updateItem: (li, item) => this.updateItemElement(li, item),
                    });

                    const totalCount = Array.isArray(state.items) ? state.items.length : 0;
                    if (totalCount !== this.lastReportedTotal) {
                        this.lastReportedTotal = totalCount;
                        this.dispatchEvent(
                            new CustomEvent("itemcountchange", {
                                detail: { total: totalCount },
                                bubbles: true,
                                composed: true,
                            }),
                        );
                    }

                    const nextTitle = state.title ?? "";
                    if (this.titleEl && !this.isTitleEditing) {
                        this.titleEl.textContent = nextTitle;
                    }

                    const attrTitle = this.getAttribute("name");
                    if (attrTitle !== nextTitle) {
                        this.suppressNameSync = true;
                        if (nextTitle) {
                            this.setAttribute("name", nextTitle);
                        } else {
                            this.removeAttribute("name");
                        }
                        this.suppressNameSync = false;
                    }

                    if (nextTitle !== this.lastReportedTitle) {
                        this.lastReportedTitle = nextTitle;
                        this.dispatchEvent(
                            new CustomEvent("titlechange", {
                                detail: { title: nextTitle },
                                bubbles: true,
                                composed: true,
                            }),
                        );
                    }

                    const forceVisible = this.editController.getForceVisibleIds();
                    let hasPendingEdit = this.editController.hasPending();

                    this.performSearch(this.searchQuery, { forceVisible });

                    let appliedPendingEdit = false;
                    if (hasPendingEdit) {
                        appliedPendingEdit = this.editController.applyPendingEdit() === true;
                        hasPendingEdit = this.editController.hasPending();
                    }

                    this.view.restoreFocus(preservedFocus, {
                        skip: hasPendingEdit || appliedPendingEdit,
                    });

                    if (this.openActionsItem && !this.listEl.contains(this.openActionsItem)) {
                        this.openActionsItem = null;
                    }
                }

                populateItemElement(li, item) {
                    if (!li) return;
                    const isOpen = li.classList.contains("task-item--actions");
                    const isDone = Boolean(item.done);
                    const itemId = item.id;
                    const text = typeof item.text === "string" ? item.text : "";

                    render(
                        html`
                            <div class="task-item__main">
                                <input
                                    type="checkbox"
                                    class="done-toggle"
                                    ?checked=${isDone}
                                />
                                <span
                                    class="text"
                                    tabindex="0"
                                    role="textbox"
                                    aria-label="Task"
                                ></span>
                                <span class="handle" aria-hidden="true"></span>
                            </div>
                            <button
                                type="button"
                                class=${`task-item__toggle ${isOpen ? "task-item__toggle--active" : "closed"}`}
                                aria-expanded=${isOpen ? "true" : "false"}
                                aria-label=${isOpen
                                    ? "Hide task actions for this task"
                                    : "Show task actions for this task"}
                                title=${isOpen ? "Hide task actions" : "Show task actions"}
                                @click=${this.handleActionToggleClick}
                            ></button>
                            <div
                                class="task-item__actions"
                                aria-hidden=${isOpen ? "false" : "true"}
                            >
                                <button
                                    type="button"
                                    class="task-move-button"
                                    title="Move this task to another list (shortcut: M)"
                                    @click=${this.handleMoveButtonClick}
                                >
                                    Move
                                </button>
                                <button
                                    type="button"
                                    class="task-delete-button danger"
                                    title="Delete this task"
                                    @click=${this.handleDeleteButtonClick}
                                >
                                    Delete
                                </button>
                            </div>
                        `,
                        li,
                    );

                    li.classList.add("task-item");
                    li.dataset.itemId = itemId;
                    li.dataset.done = isDone ? "true" : "false";
                    if (li.getAttribute("draggable") !== "true") {
                        li.setAttribute("draggable", "true");
                    }

                    const toggle = li.querySelector(".task-item__toggle");
                    this.updateActionToggleState(toggle, isOpen);

                    const textSpan = li.querySelector(".text");
                    if (textSpan) {
                        textSpan.dataset.originalText = text;
                        if (!textSpan.hasAttribute("tabindex")) {
                            textSpan.tabIndex = 0;
                        }
                        if (!textSpan.isContentEditable && textSpan.textContent !== text) {
                            textSpan.textContent = text;
                        }
                    }

                    const doneToggleInput = li.querySelector(".done-toggle");
                    if (doneToggleInput) {
                        doneToggleInput.removeEventListener("change", this.handleToggle);
                        doneToggleInput.addEventListener("change", this.handleToggle);
                    }
                }

                createItemElement(item) {
                    const li = document.createElement("li");
                    this.populateItemElement(li, item);
                    return li;
                }

                updateItemElement(li, item) {
                    this.populateItemElement(li, item);
                }

                updateActionToggleState(toggle, isOpen) {
                    if (!toggle) return;
                    toggle.setAttribute("aria-expanded", isOpen ? "true" : "false");
                    toggle.setAttribute(
                        "aria-label",
                        isOpen
                            ? "Hide task actions for this task"
                            : "Show task actions for this task",
                    );
                    toggle.title = isOpen ? "Hide task actions" : "Show task actions";
                    // toggle.textContent = isOpen ? "Â»" : "Â«";
                    toggle.classList.toggle("task-item__toggle--active", Boolean(isOpen));
                }

                openActionsForItem(li) {
                    if (!li) return;
                    if (this.openActionsItem && this.openActionsItem !== li) {
                        this.closeActionsForItem(this.openActionsItem);
                    }
                    li.classList.add("task-item--actions");
                    const actions = li.querySelector(".task-item__actions");
                    const toggle = li.querySelector(".task-item__toggle");
                    actions?.setAttribute("aria-hidden", "false");
                    this.updateActionToggleState(toggle, true);
                    this.openActionsItem = li;
                }

                closeActionsForItem(li) {
                    if (!li) return;
                    li.classList.remove("task-item--actions");
                    const actions = li.querySelector(".task-item__actions");
                    const toggle = li.querySelector(".task-item__toggle");
                    actions?.setAttribute("aria-hidden", "true");
                    this.updateActionToggleState(toggle, false);
                    if (this.openActionsItem === li) {
                        this.openActionsItem = null;
                    }
                }

                handleToggle(e) {
                    if (!e.target.classList?.contains("done-toggle")) return;
                    const li = e.target.closest("li");
                    const id = li?.dataset?.itemId;
                    if (!id || !this.store) return;
                    this.store.dispatch({
                        type: LIST_ACTIONS.setItemDone,
                        payload: { id, done: e.target.checked },
                    });
                    if (this._repository && this.listId) {
                        const promise = this._repository.toggleTask(
                            this.listId,
                            id,
                            Boolean(e.target.checked),
                        );
                        this.runRepositoryOperation(promise);
                    }
                }

                handleMoveButtonClick(event) {
                    const button = event.currentTarget;
                    const li = button?.closest("li");
                    const itemId = li?.dataset?.itemId ?? null;
                    if (!itemId) return;
                    const snapshot = this.getItemSnapshot(itemId);
                    if (!snapshot) return;
                    this.dispatchEvent(
                        new CustomEvent("taskMoveRequest", {
                            detail: {
                                itemId,
                                item: snapshot,
                                sourceListId: this.listId,
                                trigger: "button",
                            },
                            bubbles: true,
                            composed: true,
                        }),
                    );
                    if (li) {
                        this.closeActionsForItem(li);
                    }
                }

                handleDeleteButtonClick(event) {
                    const button = event.currentTarget;
                    const li = button?.closest("li");
                    const itemId = li?.dataset?.itemId ?? null;
                    if (!itemId || !this.store) return;

                    const snapshot = this.getItemSnapshot(itemId);
                    const confirmationMessage = snapshot?.text
                        ? `Delete "${snapshot.text}"?`
                        : "Delete this task?";
                    if (!window.confirm(confirmationMessage)) {
                        return;
                    }

                    const state = this.store.getState();
                    const items = Array.isArray(state?.items) ? state.items : [];
                    const currentIndex = items.findIndex((item) => item.id === itemId);
                    if (currentIndex === -1) return;

                    const nextItem = items[currentIndex + 1] ?? items[currentIndex - 1] ?? null;
                    const focusTargetId = nextItem?.id ?? null;
                    if (focusTargetId) {
                        this.editController.queue(focusTargetId, "end");
                        this.schedulePendingEditFlush();
                    } else {
                        this.editController.clear();
                    }

                    this.store.dispatch({
                        type: LIST_ACTIONS.removeItem,
                        payload: { id: itemId },
                    });
                    this.handleStoreChange();
                    if (!focusTargetId || !this.focusItemImmediately(focusTargetId, "end")) {
                        this.editController.applyPendingEdit();
                    }
                    if (this._repository && this.listId) {
                        const promise = this._repository.removeTask(this.listId, itemId);
                        this.runRepositoryOperation(promise);
                    }
                    if (li) {
                        this.closeActionsForItem(li);
                    }
                }

                handleActionToggleClick(event) {
                    const button = event.currentTarget;
                    const li = button?.closest("li");
                    if (!li) return;
                    if (li.classList.contains("task-item--actions")) {
                        this.closeActionsForItem(li);
                    } else {
                        this.openActionsForItem(li);
                    }
                }

                handleDocumentPointerDown(event) {
                    if (!this.openActionsItem) return;
                    const target = event.target;
                    if (!target) return;
                    if (this.openActionsItem.contains(target)) return;
                    this.closeActionsForItem(this.openActionsItem);
                }

                handleTouchGestureStart(event) {
                    if (!event?.changedTouches) return;
                    Array.from(event.changedTouches).forEach((touch) => {
                        const target = touch.target;
                        const element =
                            target instanceof Element ? target : event.target instanceof Element ? event.target : null;
                        if (this.openActionsItem && element && !this.openActionsItem.contains(element)) {
                            this.closeActionsForItem(this.openActionsItem);
                        }
                        const li = element?.closest?.("li") ?? null;
                        if (!li) return;
                        if (element.closest(".handle")) return;
                        if (element.closest(".task-item__actions")) return;
                        if (element.closest(".task-item__toggle")) return;
                        this.touchGestureState.set(touch.identifier, {
                            startX: touch.clientX,
                            startY: touch.clientY,
                            target: li,
                        });
                    });
                }

                handleTouchGestureEnd(event) {
                    if (!event?.changedTouches) return;
                    Array.from(event.changedTouches).forEach((touch) => {
                        const state = this.touchGestureState.get(touch.identifier);
                        if (!state) return;
                        this.touchGestureState.delete(touch.identifier);
                        const li = state.target;
                        if (!li || !li.isConnected) return;
                        const deltaX = touch.clientX - state.startX;
                        const deltaY = touch.clientY - state.startY;
                        if (Math.abs(deltaX) < 30) return;
                        if (Math.abs(deltaX) < Math.abs(deltaY)) return;
                        if (deltaX < 0) {
                            this.openActionsForItem(li);
                        } else {
                            this.closeActionsForItem(li);
                        }
                    });
                }

                handleTouchGestureCancel(event) {
                    if (!event?.changedTouches) return;
                    Array.from(event.changedTouches).forEach((touch) => {
                        this.touchGestureState.delete(touch.identifier);
                    });
                }

                handleItemKeyDown(event) {
                    if (!event || event.defaultPrevented) return;
                    if (event.isComposing) return;
                    const key = event.key?.toLowerCase?.() ?? "";
                    if (key !== "m") return;
                    if (event.metaKey || event.ctrlKey || event.altKey) return;
                    const target = event.target;
                    if (!target) return;
                    if (target.isContentEditable) return;
                    const li = target.closest?.("li");
                    if (!li) return;
                    const itemId = li.dataset?.itemId ?? null;
                    if (!itemId) return;
                    const snapshot = this.getItemSnapshot(itemId);
                    if (!snapshot) return;
                    event.preventDefault();
                    this.dispatchEvent(
                        new CustomEvent("taskMoveRequest", {
                            detail: {
                                itemId,
                                item: snapshot,
                                sourceListId: this.listId,
                                trigger: "shortcut",
                            },
                            bubbles: true,
                            composed: true,
                        }),
                    );
                }

                handleFocusIn(event) {
                    const target = event.target;
                    const li = target?.closest?.("li");
                    const itemId = li?.dataset?.itemId ?? null;
                    if (!itemId) return;
                    this.lastFocusedItemId = itemId;
                    this.dispatchEvent(
                        new CustomEvent("taskFocus", {
                            detail: {
                                itemId,
                                sourceListId: this.listId,
                            },
                            bubbles: true,
                            composed: true,
                        }),
                    );
                }

                handleListDragStart(event) {
                    const li = event?.target?.closest?.("li");
                    const itemId = li?.dataset?.itemId ?? null;
                    if (!itemId) return;
                    const snapshot = this.getItemSnapshot(itemId);
                    if (!snapshot) return;
                    const transfer = event.dataTransfer;
                    if (!transfer) return;
                    const payload = {
                        itemId,
                        item: snapshot,
                        sourceListId: this.listId,
                        trigger: "drag",
                    };
                    try {
                        transfer.setData("application/x-a4-task", JSON.stringify(payload));
                    } catch (err) {
                        // Ignore inability to set custom data
                    }
                    try {
                        transfer.setData("text/plain", snapshot.text ?? "");
                    } catch (err) {
                        // ignore
                    }
                    transfer.effectAllowed = "move";
                }

                handleEditCommit({ element, newText, previousText }) {
                    if (!element || !this.store) {
                        this.performSearch(this.searchQuery);
                        return;
                    }
                    const li = element.closest("li");
                    const id = li?.dataset?.itemId;
                    if (!id) {
                        this.performSearch(this.searchQuery);
                        return;
                    }
                    if (typeof newText !== "string") {
                        this.performSearch(this.searchQuery);
                        return;
                    }
                    const currentState = this.store.getState();
                    const stateItem = currentState?.items?.find((item) => item.id === id);
                    if (stateItem && stateItem.text !== previousText) {
                        const authoritativeText = stateItem.text ?? "";
                        element.textContent = authoritativeText;
                        element.dataset.originalText = authoritativeText;
                        this.performSearch(this.searchQuery);
                        return;
                    }
                    if (newText === previousText) {
                        this.performSearch(this.searchQuery);
                        return;
                    }
                    this.store.dispatch({
                        type: LIST_ACTIONS.updateItemText,
                        payload: { id, text: newText },
                    });
                    if (this._repository && this.listId) {
                        const promise = this._repository.updateTask(this.listId, id, {
                            text: newText,
                        });
                        this.runRepositoryOperation(promise);
                    }
                }

                scheduleReorderUpdate() {
                    if (!this.store || !this.listEl) return;
                    Promise.resolve().then(() => {
                        if (!this.store || !this.listEl) return;
                        const previousState = this.store.getState();
                        const prevOrder = Array.isArray(previousState?.items)
                            ? previousState.items.map((item) => item.id)
                            : [];
                        const order = Array.from(this.listEl.children)
                            .filter((li) => !li.classList.contains("placeholder"))
                            .map((li) => li.dataset.itemId)
                            .filter(Boolean);
                        if (!order.length) return;
                        this.store.dispatch({
                            type: LIST_ACTIONS.reorderItems,
                            payload: { order },
                        });
                        if (this._repository && this.listId) {
                            let movedId = null;
                            for (let i = 0; i < order.length; i++) {
                                if (order[i] !== prevOrder[i]) {
                                    movedId = order[i];
                                    break;
                                }
                            }
                            if (!movedId) return;
                            const targetIndex = order.indexOf(movedId);
                            const beforeNeighbor = order[targetIndex - 1] ?? null;
                            const afterNeighbor = order[targetIndex + 1] ?? null;
                            const promise = this._repository.moveTaskWithinList(
                                this.listId,
                                movedId,
                                {
                                    afterId: beforeNeighbor ?? undefined,
                                    beforeId: afterNeighbor ?? undefined,
                                },
                            );
                            this.runRepositoryOperation(promise);
                        }
                    });
                }

                handleItemBlur(e) {
                    const textEl = e.target.classList?.contains("text") ? e.target : null;
                    if (!textEl) return;
                    textEl.dataset.originalText = textEl.textContent;
                    this.performSearch(this.searchQuery);
                }

                // Keeps filtering and highlighting in sync with state changes so users never see
                // stale markup, while forcing certain ids visible when edits demand it.
                performSearch(query, options = {}) {
                    if (!this.listEl) return;
                    this.searchQuery = query;
                    const tokens = tokenizeSearchQuery(query);
                    const forceVisible = options?.forceVisible ?? null;

                    let visibleCount = 0;

                    this.listEl.querySelectorAll("li").forEach((li) => {
                        if (li.classList.contains("placeholder")) return;
                        const textEl = li.querySelector(".text");
                        if (!textEl) return;
                        const isEditing = textEl.isContentEditable;
                        const isDone = li.dataset.done === "true";

                        const original =
                            textEl.dataset.originalText != null
                                ? textEl.dataset.originalText
                                : (textEl.dataset.originalText = textEl.textContent);

                        if (isEditing) {
                            li.hidden = false;
                            visibleCount += 1;
                            return;
                        }

                        if (
                            forceVisible &&
                            li.dataset.itemId &&
                            forceVisible.has(li.dataset.itemId)
                        ) {
                            li.hidden = false;
                            textEl.textContent = original;
                            visibleCount += 1;
                            return;
                        }

                        const result = evaluateSearchEntry({
                            originalText: original,
                            tokens,
                            patternConfig: this.patternConfig,
                            showDone: this.showDone,
                            isDone,
                        });

                        li.hidden = result.hidden;
                        if (result.hidden || result.markup == null) {
                            textEl.textContent = original;
                            return;
                        }
                        textEl.innerHTML = result.markup;
                        if (!li.hidden) {
                            visibleCount += 1;
                        }
                    });

                    this.dragBehavior?.invalidateItemsCache();

                    if (
                        visibleCount !== this.lastReportedMatches ||
                        query !== this.lastReportedQuery
                    ) {
                        this.lastReportedMatches = visibleCount;
                        this.lastReportedQuery = query;
                        this.dispatchEvent(
                            new CustomEvent("searchresultschange", {
                                detail: {
                                    matches: visibleCount,
                                    query,
                                },
                                bubbles: true,
                                composed: true,
                            }),
                        );
                    }

                    const shouldShowEmpty =
                        typeof this.searchQuery === "string" &&
                        this.searchQuery.trim().length > 0 &&
                        visibleCount === 0;
                    if (this.emptyStateEl) {
                        this.emptyStateEl.hidden = !shouldShowEmpty;
                    }
                    this.classList.toggle("tasklist-no-matches", shouldShowEmpty);
                }

                applyFilter(query) {
                    const value = typeof query === "string" ? query : "";
                    if (this.searchInput) {
                        this.searchInput.value = value;
                    }
                    this.performSearch(value);
                }

                clearFilter() {
                    this.applyFilter("");
                }

                getItemSnapshot(itemId) {
                    if (!this.store || !itemId) return null;
                    const state = this.store.getState();
                    const items = Array.isArray(state?.items) ? state.items : [];
                    const found = items.find((item) => item.id === itemId);
                    return found ? { ...found } : null;
                }

                removeItemById(itemId) {
                    if (!this.store || !itemId) return false;
                    const state = this.store.getState();
                    if (!state?.items?.some((item) => item.id === itemId)) {
                        return false;
                    }
                    this.store.dispatch({
                        type: LIST_ACTIONS.removeItem,
                        payload: { id: itemId },
                    });
                    this.handleStoreChange();
                    return true;
                }

                prependItem(item) {
                    if (!this.store || !item || !item.id) return false;
                    this.store.dispatch({
                        type: LIST_ACTIONS.insertItem,
                        payload: {
                            index: 0,
                            item: {
                                id: item.id,
                                text: typeof item.text === "string" ? item.text : "",
                                done: Boolean(item.done),
                            },
                        },
                    });
                    this.handleStoreChange();
                    return true;
                }

                focusItem(itemId) {
                    if (!this.listEl || !itemId) return false;
                    const selectorId = escapeSelectorId(itemId);
                    const targetLi = this.listEl.querySelector(`li[data-item-id="${selectorId}"]`);
                    if (!targetLi) return false;
                    const textEl = targetLi.querySelector(".text");
                    if (textEl) {
                        textEl.focus();
                        return true;
                    }
                    return false;
                }

                cancelActiveDrag() {
                    this.dragBehavior?.cancel?.();
                }

                setListName(name) {
                    const nextTitle = typeof name === "string" ? name : "";
                    if (this.store) {
                        this.store.dispatch({
                            type: LIST_ACTIONS.setTitle,
                            payload: { title: nextTitle },
                        });
                    } else {
                        this.setAttribute("name", nextTitle);
                        this.syncTitle();
                    }
                }

                getTotalItemCount() {
                    if (!this.store) return 0;
                    const state = this.store.getState();
                    return Array.isArray(state?.items) ? state.items.length : 0;
                }

                getSearchMatchCount() {
                    if (typeof this.lastReportedMatches === "number") {
                        return this.lastReportedMatches;
                    }
                    return this.getTotalItemCount();
                }

                get listId() {
                    return this.listIdentifier;
                }

                set listId(value) {
                    if (value == null) {
                        this.listIdentifier = null;
                        delete this.dataset.listId;
                        this.refreshRepositorySubscription();
                        return;
                    }
                    this.listIdentifier = String(value);
                    this.dataset.listId = this.listIdentifier;
                    this.refreshRepositorySubscription();
                }

                get listRepository() {
                    return this._repository;
                }

                set listRepository(value) {
                    if (this._repository === value) return;
                    this._repository = value ?? null;
                    this.refreshRepositorySubscription();
                }

                get name() {
                    return this.getAttribute("name") ?? "";
                }

                set name(value) {
                    if (value == null) {
                        this.removeAttribute("name");
                    } else {
                        this.setAttribute("name", String(value));
                    }
                }
            }

            customElements.define("a4-tasklist", A4TaskList);
            document.addEventListener(
                "keydown",
                (event) => {
                    if (!event || event.defaultPrevented) return;
                    const host = event.target?.closest?.("a4-tasklist");
                    if (!host || typeof host.handleItemKeyDown !== "function") return;
                    host.handleItemKeyDown(event);
                },
                true,
            );

            class Sidebar {
                constructor(element, handlers = {}) {
                    this.element = element;
                    this.handlers = handlers;
                    this.searchInput =
                        element?.querySelector("[data-role='global-search']") ?? null;
                    this.listContainer =
                        element?.querySelector("[data-role='sidebar-list']") ?? null;
                    this.addButton = element?.querySelector("[data-role='add-list']") ?? null;
                    this.deleteButton = element?.querySelector("[data-role='delete-list']") ?? null;
                    this.searchDebounceId = null;
                    this.currentLists = [];
                    this.activeListId = null;
                    this.currentSearch = "";
                    this.dropTargetDepth = new Map();
                    this.handleSearchInput = this.handleSearchInput.bind(this);
                    this.handleSearchKeyDown = this.handleSearchKeyDown.bind(this);
                    this.handleListDragEnter = this.handleListDragEnter.bind(this);
                    this.handleListDragOver = this.handleListDragOver.bind(this);
                    this.handleListDragLeave = this.handleListDragLeave.bind(this);
                    this.handleListDrop = this.handleListDrop.bind(this);
                    this.handleGlobalDragEnd = this.handleGlobalDragEnd.bind(this);
                    this.handleSidebarButtonClick = this.handleSidebarButtonClick.bind(this);
                }

                init() {
                    this.searchInput?.addEventListener("input", this.handleSearchInput);
                    this.searchInput?.addEventListener("keydown", this.handleSearchKeyDown);
                    this.addButton?.addEventListener("click", () => this.handlers.onAddList?.());
                    this.deleteButton?.addEventListener("click", () =>
                        this.handlers.onDeleteList?.(),
                    );
                    this.renderLists();
                    this.updateActionStates();
                    document.addEventListener("dragend", this.handleGlobalDragEnd);
                }

                destroy() {
                    this.searchInput?.removeEventListener("input", this.handleSearchInput);
                    this.searchInput?.removeEventListener("keydown", this.handleSearchKeyDown);
                    clearTimeout(this.searchDebounceId);
                    document.removeEventListener("dragend", this.handleGlobalDragEnd);
                }

                setSearchValue(value) {
                    const next = value ?? "";
                    if (this.searchInput && this.searchInput.value !== next) {
                        this.searchInput.value = next;
                    }
                    this.currentSearch = next;
                }

                setLists(lists, { activeListId, searchQuery } = {}) {
                    this.currentLists = Array.isArray(lists) ? lists : [];
                    this.activeListId = activeListId ?? null;
                    if (typeof searchQuery === "string") {
                        this.setSearchValue(searchQuery);
                    }
                    this.renderLists();
                    this.updateActionStates();
                }

                updateActionStates() {
                    const listCount = this.currentLists.length;
                    if (this.deleteButton) {
                        this.deleteButton.disabled = listCount <= 1 || !this.activeListId;
                    }
                }

                renderLists() {
                    if (!this.listContainer) return;
                    render(
                        html`${this.currentLists.map((list) => {
                            const isActive = list.id === this.activeListId;
                            const buttonClass = isActive
                                ? "sidebar-list-button is-active"
                                : "sidebar-list-button";
                            return html`
                                <li>
                                    <button
                                        type="button"
                                        class=${buttonClass}
                                        data-list-id=${list.id}
                                        aria-current=${isActive ? "true" : undefined}
                                        @click=${this.handleSidebarButtonClick}
                                        @dragenter=${this.handleListDragEnter}
                                        @dragover=${this.handleListDragOver}
                                        @dragleave=${this.handleListDragLeave}
                                        @drop=${this.handleListDrop}
                                    >
                                        <span class="sidebar-list-label">${list.name}</span>
                                        <span class="sidebar-list-count">${list.countLabel ?? ""}</span>
                                    </button>
                                </li>
                            `;
                        })}`,
                        this.listContainer,
                    );
                }

                handleSidebarButtonClick(event) {
                    const button = event.currentTarget;
                    const listId = button?.dataset?.listId;
                    if (!listId) return;
                    this.handlers.onSelectList?.(listId);
                }

                handleSearchInput(event) {
                    const value = event?.target?.value ?? "";
                    clearTimeout(this.searchDebounceId);
                    this.searchDebounceId = setTimeout(() => {
                        this.handlers.onSearchChange?.(value);
                    }, 150);
                }

                handleSearchKeyDown(event) {
                    if (event.key === "Escape") {
                        event.preventDefault();
                        if (this.searchInput) {
                            this.searchInput.value = "";
                        }
                        this.handlers.onSearchChange?.("");
                    }
                }

                parseTaskData(dataTransfer) {
                    if (!dataTransfer) return null;
                    const types = Array.from(dataTransfer.types ?? []);
                    if (!types.includes("application/x-a4-task")) return null;
                    try {
                        const payload = dataTransfer.getData("application/x-a4-task");
                        if (!payload) return null;
                        return JSON.parse(payload);
                    } catch (err) {
                        return null;
                    }
                }

                handleListDragEnter(event) {
                    const button = event.currentTarget;
                    const payload = this.parseTaskData(event.dataTransfer);
                    if (!payload) return;
                    if (payload.sourceListId === button.dataset.listId) return;
                    event.preventDefault();
                    if (this.dropTargetDepth.size) {
                        const others = Array.from(this.dropTargetDepth.keys()).filter(
                            (btn) => btn !== button,
                        );
                        others.forEach((btn) => {
                            btn.classList.remove("is-drop-target");
                            this.dropTargetDepth.delete(btn);
                        });
                    }
                    const nextDepth = (this.dropTargetDepth.get(button) ?? 0) + 1;
                    this.dropTargetDepth.set(button, nextDepth);
                    button.classList.add("is-drop-target");
                }

                handleListDragOver(event) {
                    const button = event.currentTarget;
                    const payload = this.parseTaskData(event.dataTransfer);
                    if (!payload) return;
                    if (payload.sourceListId === button.dataset.listId) return;
                    event.preventDefault();
                    event.dataTransfer.dropEffect = "move";
                }

                handleListDragLeave(event) {
                    const button = event.currentTarget;
                    if (button.contains(event.relatedTarget)) {
                        return;
                    }
                    const nextDepth = (this.dropTargetDepth.get(button) ?? 1) - 1;
                    if (nextDepth <= 0) {
                        this.dropTargetDepth.delete(button);
                        button.classList.remove("is-drop-target");
                    } else {
                        this.dropTargetDepth.set(button, nextDepth);
                    }
                }

                handleListDrop(event) {
                    const button = event.currentTarget;
                    const payload = this.parseTaskData(event.dataTransfer);
                    button.classList.remove("is-drop-target");
                    this.dropTargetDepth.delete(button);
                    if (!payload) return;
                    const targetListId = button.dataset.listId;
                    if (!targetListId || payload.sourceListId === targetListId) return;
                    event.preventDefault();
                    this.handlers.onItemDropped?.(payload, targetListId);
                }

                handleGlobalDragEnd() {
                    if (!this.dropTargetDepth.size) return;
                    this.dropTargetDepth.forEach((_, button) => {
                        button.classList.remove("is-drop-target");
                    });
                    this.dropTargetDepth.clear();
                }
            }

            class KeyboardMoveDialog {
                constructor(element) {
                    this.root = element ?? null;
                    this.backdropEl =
                        element?.querySelector("[data-role='move-dialog-backdrop']") ?? null;
                    this.contentEl = element?.querySelector(".move-dialog__content") ?? null;
                    this.optionsListEl =
                        element?.querySelector("[data-role='move-dialog-options']") ?? null;
                    this.cancelButton =
                        element?.querySelector("[data-role='move-dialog-cancel']") ?? null;
                    this.optionButtons = [];
                    this.isOpen = false;
                    this.currentContext = null;

                    this.handleKeyDown = this.handleKeyDown.bind(this);
                    this.handleCancel = this.handleCancel.bind(this);
                    this.handleBackdropClick = this.handleBackdropClick.bind(this);
                    this.handleOptionClick = this.handleOptionClick.bind(this);

                    this.cancelButton?.addEventListener("click", this.handleCancel);
                    this.backdropEl?.addEventListener("click", this.handleBackdropClick);
                }

                open(options = {}) {
                    if (!this.root || !this.optionsListEl) return;
                    const targets = Array.isArray(options.targets) ? options.targets : [];
                    if (!targets.length) return;
                    this.close({ restoreFocus: false });
                    this.currentContext = { ...options };
                    this.renderOptions(targets);
                    this.root.hidden = false;
                    this.root.setAttribute("aria-hidden", "false");
                    this.isOpen = true;
                    this.contentEl?.addEventListener("keydown", this.handleKeyDown);
                    requestAnimationFrame(() => {
                        if (this.optionButtons[0]) {
                            this.optionButtons[0].focus();
                        } else if (this.cancelButton) {
                            this.cancelButton.focus();
                        }
                    });
                }

                renderOptions(targets) {
                    if (!this.optionsListEl) {
                        this.optionButtons = [];
                        return;
                    }
                    render(
                        html`${targets.map(
                            (target) => html`
                                <li>
                                    <button
                                        type="button"
                                        class="move-dialog__option"
                                        data-list-id=${target.id}
                                        @click=${this.handleOptionClick}
                                    >
                                        <span class="move-dialog__option-name">${target.name}</span>
                                        <span class="move-dialog__option-count">${target.countLabel ?? ""}</span>
                                    </button>
                                </li>
                            `,
                        )}`,
                        this.optionsListEl,
                    );
                    this.optionButtons = Array.from(
                        this.optionsListEl.querySelectorAll(".move-dialog__option"),
                    );
                }

                clearOptions() {
                    if (!this.optionsListEl) {
                        this.optionButtons = [];
                        return;
                    }
                    render(html``, this.optionsListEl);
                    this.optionButtons = [];
                }

                close({ restoreFocus = true } = {}) {
                    if (!this.isOpen) {
                        if (!restoreFocus) {
                            this.currentContext = null;
                        }
                        return;
                    }
                    this.isOpen = false;
                    this.contentEl?.removeEventListener("keydown", this.handleKeyDown);
                    this.clearOptions();
                    if (this.root) {
                        this.root.hidden = true;
                        this.root.setAttribute("aria-hidden", "true");
                    }
                    const context = this.currentContext;
                    this.currentContext = null;
                    if (restoreFocus && context?.restoreFocus) {
                        try {
                            context.restoreFocus();
                        } catch (err) {
                            // ignore focus errors
                        }
                    }
                }

                handleOptionClick(event) {
                    const button = event.currentTarget;
                    const listId = button?.dataset?.listId;
                    if (!listId) return;
                    const context = this.currentContext;
                    if (!context) return;
                    this.close({ restoreFocus: false });
                    context.onConfirm?.({ ...context, targetListId: listId });
                }

                handleCancel() {
                    const context = this.currentContext;
                    context?.onCancel?.(context);
                    this.close({ restoreFocus: true });
                }

                handleBackdropClick() {
                    this.handleCancel();
                }

                handleKeyDown(event) {
                    if (!this.isOpen) return;
                    if (event.key === "Escape") {
                        event.preventDefault();
                        this.handleCancel();
                        return;
                    }
                    if (event.key === "ArrowDown" || event.key === "ArrowUp") {
                        const forward = event.key === "ArrowDown" ? 1 : -1;
                        const focusables = this.getFocusableElements();
                        if (!focusables.length) return;
                        event.preventDefault();
                        const currentIndex = focusables.indexOf(document.activeElement);
                        let nextIndex = currentIndex + forward;
                        if (nextIndex < 0) nextIndex = focusables.length - 1;
                        if (nextIndex >= focusables.length) nextIndex = 0;
                        focusables[nextIndex].focus();
                        return;
                    }
                    if (event.key === "Tab") {
                        const focusables = this.getFocusableElements();
                        if (!focusables.length) return;
                        event.preventDefault();
                        const direction = event.shiftKey ? -1 : 1;
                        const currentIndex = focusables.indexOf(document.activeElement);
                        let nextIndex = currentIndex + direction;
                        if (nextIndex < 0) nextIndex = focusables.length - 1;
                        if (nextIndex >= focusables.length) nextIndex = 0;
                        focusables[nextIndex].focus();
                    }
                }

                getFocusableElements() {
                    const focusables = [];
                    this.optionButtons.forEach((button) => focusables.push(button));
                    if (this.cancelButton) {
                        focusables.push(this.cancelButton);
                    }
                    return focusables;
                }
            }

            class ListsApp {
            constructor(options = {}) {
                this.sidebarElement = options.sidebarElement ?? null;
                this.mainElement = options.mainElement ?? null;
                this.listsContainer = options.listsContainer ?? null;
                this.mainTitleEl = options.mainTitleElement ?? null;
                this.moveDialogElement = options.moveDialogElement ?? null;

                this.listRegistry = new Map();
                this.listOrder = [];
                this.activeListId = null;
                this.searchQuery = "";
                this.isApplyingSearch = false;
                this.lastFocused = null;
                this.pendingActiveListId = null;

                this.repository = options.listRepository ?? new ListRepository();
                this.registryUnsubscribe = null;

                this.handleSearchChange = this.handleSearchChange.bind(this);
                this.handleListSelection = this.handleListSelection.bind(this);
                this.handleAddList = this.handleAddList.bind(this);
                this.handleDeleteList = this.handleDeleteList.bind(this);
                    this.handleSidebarDrop = this.handleSidebarDrop.bind(this);
                this.handleTaskMoveRequest = this.handleTaskMoveRequest.bind(this);
                this.handleItemCountChange = this.handleItemCountChange.bind(this);
                this.handleSearchResultsChange = this.handleSearchResultsChange.bind(this);
                this.handleListFocus = this.handleListFocus.bind(this);
                this.handleListTitleChange = this.handleListTitleChange.bind(this);
                this.handleRepositoryRegistryChange = this.handleRepositoryRegistryChange.bind(this);

                this.sidebar = new Sidebar(this.sidebarElement, {
                    onSearchChange: this.handleSearchChange,
                    onSelectList: this.handleListSelection,
                    onAddList: this.handleAddList,
                        onDeleteList: this.handleDeleteList,
                        onItemDropped: this.handleSidebarDrop,
                    });

                    this.moveDialog = new KeyboardMoveDialog(this.moveDialogElement);
                }

                async initialize() {
                    this.sidebar.init();
                    await this.repository.initialize();
                    if (!this.registryUnsubscribe) {
                        this.registryUnsubscribe = this.repository.subscribeRegistry(
                            this.handleRepositoryRegistryChange,
                            { emitCurrent: false },
                        );
                    }
                    this.handleRepositoryRegistryChange(
                        this.repository.getRegistrySnapshot(),
                    );
                    this.sidebar.setSearchValue(this.searchQuery);
                }

                createList(config, { makeActive = false } = {}) {
                    if (!this.listsContainer) return null;
                    const id = config.id ?? generateListId("list");
                    const state = {
                        title:
                            typeof config.title === "string" && config.title.length
                                ? config.title
                                : "",
                        items: Array.isArray(config.items) ? config.items : [],
                    };
                    const displayName = state.title.length ? state.title : "Untitled List";
                    const existing = this.listRegistry.get(id);
                    if (existing) {
                        existing.name = displayName;
                        existing.element.listRepository = this.repository;
                        existing.element.initialState = state;
                        if (makeActive) {
                            this.setActiveList(id);
                        }
                        return existing;
                    }

                    const wrapper = document.createElement("section");
                    wrapper.className = "list-section";
                    wrapper.dataset.listId = id;

                    const items = Array.isArray(config.items)
                        ? config.items.map((item) => ({ ...item }))
                        : [];

                    render(
                        html`
                            <a4-tasklist name=${name}></a4-tasklist>
                        `,
                        wrapper,
                    );
                    this.listsContainer.appendChild(wrapper);

                    const listElement = wrapper.querySelector("a4-tasklist");
                    if (!listElement) {
                        wrapper.remove();
                        return null;
                    }
                    listElement.listId = id;
                    listElement.listRepository = this.repository;
                    listElement.initialState = {
                        title: state.title,
                        items,
                    };

                    const record = {
                        id,
                        name: displayName,
                        element: listElement,
                        wrapper,
                        totalCount: listElement.getTotalItemCount(),
                        matchCount: listElement.getSearchMatchCount(),
                        flashTimer: null,
                    };

                    this.listRegistry.set(id, record);
                    this.registerListEvents(record);

                    if (makeActive || !this.activeListId) {
                        this.activeListId = id;
                    }
                    this.updateListVisibility();
                    return record;
                }

                registerListEvents(record) {
                    const element = record.element;
                    element.addEventListener("taskMoveRequest", this.handleTaskMoveRequest);
                    element.addEventListener("itemcountchange", this.handleItemCountChange);
                    element.addEventListener("searchresultschange", this.handleSearchResultsChange);
                    element.addEventListener("taskFocus", this.handleListFocus);
                    element.addEventListener("titlechange", this.handleListTitleChange);
                }

                removeList(listId) {
                    const record = this.listRegistry.get(listId);
                    if (!record) return;
                    const element = record.element;
                    element?.dispose?.();
                    element.removeEventListener("taskMoveRequest", this.handleTaskMoveRequest);
                    element.removeEventListener("itemcountchange", this.handleItemCountChange);
                    element.removeEventListener(
                        "searchresultschange",
                        this.handleSearchResultsChange,
                    );
                    element.removeEventListener("taskFocus", this.handleListFocus);
                    element.removeEventListener("titlechange", this.handleListTitleChange);
                    if (record.flashTimer) {
                        clearTimeout(record.flashTimer);
                        record.flashTimer = null;
                    }
                    record.wrapper.remove();
                    this.listRegistry.delete(listId);
                    this.listOrder = this.listOrder.filter((id) => id !== listId);
                }

                handleSearchChange(value) {
                    const next = typeof value === "string" ? value : "";
                    if (next === this.searchQuery) return;
                    this.searchQuery = next;
                    this.applySearchToLists();
                    this.refreshSidebar();
                    this.updateMainHeading();
                }

                handleListSelection(listId) {
                    if (!listId) return;
                    this.setActiveList(listId);
                }

                handleAddList() {
                    const response = window.prompt?.("Name for the new list", "New List");
                    if (response == null) return;
                    const trimmed = response.trim();
                    if (!trimmed.length) return;
                    const id = generateListId("list");
                    this.pendingActiveListId = id;
                    Promise.resolve(
                        this.repository.createList({ listId: id, title: trimmed }),
                    )
                        .then(() => {
                            this.setActiveList(id);
                        })
                        .catch(() => {});
                }

                handleListTitleChange(event) {
                    const element = event.currentTarget ?? null;
                    const listId = element?.listId ?? element?.dataset?.listId ?? null;
                    const detailTitle =
                        typeof event.detail?.title === "string" ? event.detail.title : "";
                    if (!listId) return;
                    const trimmed = detailTitle.trim();
                    const nextName = trimmed.length ? trimmed : "Untitled List";
                    const record = this.listRegistry.get(listId);
                    if (!record || record.name === nextName) return;
                    record.name = nextName;
                    this.refreshSidebar();
                    if (this.activeListId === listId) {
                        this.updateMainHeading();
                    }
                }

                handleRepositoryRegistryChange(snapshot = []) {
                    if (!Array.isArray(snapshot)) return;
                    const seen = new Set();
                    snapshot.forEach((entry, index) => {
                        const listId = entry?.id;
                        if (!listId) return;
                        const state = this.repository.getListState(listId);
                        const titleCandidate = state?.title ?? entry.title ?? "";
                        const record = this.createList(
                            {
                                id: listId,
                                title: titleCandidate,
                                items: state?.items ?? [],
                            },
                            { makeActive: !this.activeListId && index === 0 },
                        );
                        if (record) {
                            const normalized = titleCandidate?.trim?.() ?? "";
                            record.name = normalized.length ? normalized : "Untitled List";
                            record.totalCount = record.element.getTotalItemCount();
                            record.matchCount = record.element.getSearchMatchCount();
                        }
                        seen.add(listId);
                    });

                    Array.from(this.listRegistry.keys()).forEach((id) => {
                        if (!seen.has(id)) {
                            this.removeList(id);
                        }
                    });

                    this.listOrder = snapshot
                        .map((entry) => entry.id)
                        .filter((id) => this.listRegistry.has(id));

                    if (this.listsContainer) {
                        this.listOrder.forEach((id) => {
                            const record = this.listRegistry.get(id);
                            if (record) {
                                this.listsContainer.appendChild(record.wrapper);
                            }
                        });
                    }

                    if (this.activeListId && !this.listRegistry.has(this.activeListId)) {
                        this.activeListId = null;
                    }
                    if (!this.activeListId && this.listOrder.length) {
                        this.activeListId = this.listOrder[0];
                    }

                    if (
                        this.pendingActiveListId &&
                        this.listRegistry.has(this.pendingActiveListId)
                    ) {
                        this.setActiveList(this.pendingActiveListId);
                        this.pendingActiveListId = null;
                    }

                    this.applySearchToLists();
                    this.refreshSidebar();
                    this.updateMainHeading();
                }

                handleDeleteList() {
                    if (!this.activeListId) return;
                    if (this.listOrder.length <= 1) {
                        window.alert?.("At least one list must remain.");
                        return;
                    }
                    const record = this.listRegistry.get(this.activeListId);
                    if (!record) return;
                    const confirmed = window.confirm?.(
                        `Delete "${record.name}" and all of its tasks?`,
                    );
                    if (!confirmed) return;
                    const removeId = record.id;
                    const currentIndex = this.listOrder.indexOf(removeId);
                    let fallbackId = null;
                    if (currentIndex !== -1) {
                        fallbackId = this.listOrder[currentIndex + 1] ?? null;
                        if (!fallbackId) {
                            fallbackId = this.listOrder[currentIndex - 1] ?? null;
                        }
                    }
                    if (!fallbackId) {
                        fallbackId = this.listOrder.find((id) => id !== removeId) ?? null;
                    }
                    if (fallbackId) {
                        this.pendingActiveListId = fallbackId;
                    } else {
                        this.pendingActiveListId = null;
                    }
                    Promise.resolve(this.repository.removeList(removeId))
                        .catch(() => {
                            if (this.pendingActiveListId === fallbackId) {
                                this.pendingActiveListId = null;
                            }
                        });
                }

                handleSidebarDrop(payload, targetListId) {
                    const sourceListId = payload?.sourceListId;
                    const itemId = payload?.itemId;
                    const item = payload?.item ?? null;
                    if (!sourceListId || !targetListId || !itemId) return;
                    if (sourceListId === targetListId) return;
                    this.moveTask(sourceListId, targetListId, itemId, {
                        snapshot: item,
                        focus: false,
                    });
                }

                handleTaskMoveRequest(event) {
                    const detail = event.detail ?? {};
                    const sourceListId = detail.sourceListId ?? event.currentTarget?.listId ?? null;
                    const itemId = detail.itemId ?? null;
                    if (!sourceListId || !itemId) return;
                    const record = this.listRegistry.get(sourceListId);
                    if (!record) return;
                    const snapshot = detail.item ?? record.element.getItemSnapshot(itemId);
                    if (!snapshot) return;
                    const searchActive = this.isSearchMode();
                    const targets = this.listOrder
                        .map((id) => this.listRegistry.get(id))
                        .filter((rec) => rec && rec.id !== sourceListId)
                        .map((rec) => ({
                            id: rec.id,
                            name: rec.name,
                            countLabel: searchActive
                                ? this.formatMatchCount(
                                      rec.matchCount ?? rec.element.getSearchMatchCount(),
                                  )
                                : this.formatTotalCount(
                                      rec.totalCount ?? rec.element.getTotalItemCount(),
                                  ),
                        }));
                    if (!targets.length) return;
                    const restoreFocus = () => {
                        record.element.focusItem(itemId);
                    };
                    this.moveDialog.open({
                        sourceListId,
                        itemId,
                        task: snapshot,
                        trigger: detail.trigger ?? "button",
                        targets,
                        restoreFocus: detail.trigger === "shortcut" ? restoreFocus : null,
                        onConfirm: ({ targetListId }) => {
                            this.moveTask(sourceListId, targetListId, itemId, {
                                snapshot,
                                focus: detail.trigger === "shortcut",
                            });
                        },
                        onCancel: () => {
                            if (detail.trigger === "shortcut") {
                                restoreFocus();
                            }
                        },
                    });
                }

                handleItemCountChange(event) {
                    const listId = event.currentTarget?.listId ?? null;
                    const record = this.listRegistry.get(listId);
                    if (!record) return;
                    const total = Number(event.detail?.total);
                    if (Number.isFinite(total)) {
                        record.totalCount = total;
                    } else {
                        record.totalCount = record.element.getTotalItemCount();
                    }
                    if (!this.isApplyingSearch) {
                        this.refreshSidebar();
                    }
                }

                handleSearchResultsChange(event) {
                    const listId = event.currentTarget?.listId ?? null;
                    const record = this.listRegistry.get(listId);
                    if (!record) return;
                    const matches = Number(event.detail?.matches);
                    if (Number.isFinite(matches)) {
                        record.matchCount = matches;
                    } else {
                        record.matchCount = record.element.getSearchMatchCount();
                    }
                    const detailQuery =
                        typeof event.detail?.query === "string" ? event.detail.query : null;
                    const searchActive = this.searchQuery.trim().length > 0;
                    if (
                        !this.isApplyingSearch &&
                        searchActive &&
                        (detailQuery == null || detailQuery.trim().length === 0)
                    ) {
                        this.handleSearchChange("");
                        return;
                    }
                    if (!this.isApplyingSearch) {
                        this.refreshSidebar();
                    }
                }

                handleListFocus(event) {
                    const detail = event.detail ?? {};
                    this.lastFocused = {
                        listId: detail.sourceListId ?? event.currentTarget?.listId ?? null,
                        itemId: detail.itemId ?? null,
                    };
                }

                setActiveList(listId) {
                    if (!listId || !this.listRegistry.has(listId)) return;
                    if (this.activeListId === listId && !this.isSearchMode()) {
                        return;
                    }
                    this.activeListId = listId;
                    this.updateListVisibility();
                    this.refreshSidebar();
                    this.updateMainHeading();
                }

                applySearchToLists() {
                    this.isApplyingSearch = true;
                    this.listOrder.forEach((id) => {
                        const record = this.listRegistry.get(id);
                        if (!record) return;
                        record.element.applyFilter(this.searchQuery);
                        record.matchCount = record.element.getSearchMatchCount();
                    });
                    this.isApplyingSearch = false;
                    this.updateSearchMode();
                }

                moveTask(sourceListId, targetListId, itemId, options = {}) {
                    if (!itemId || sourceListId === targetListId) return;
                    const sourceRecord = this.listRegistry.get(sourceListId);
                    const targetRecord = this.listRegistry.get(targetListId);
                    if (!sourceRecord || !targetRecord) return;
                    const snapshot =
                        options.snapshot ?? sourceRecord.element.getItemSnapshot(itemId);
                    if (!snapshot) return;
                    sourceRecord.element.cancelActiveDrag?.();
                    const targetStateBefore = targetRecord.element.store?.getState?.();
                    const fallbackBeforeId = Array.isArray(targetStateBefore?.items)
                        ? targetStateBefore.items[0]?.id ?? undefined
                        : undefined;
                    const removed = sourceRecord.element.removeItemById(itemId);
                    if (!removed) return;
                    targetRecord.element.prependItem(snapshot);
                    this.refreshMetrics(sourceRecord);
                    this.refreshMetrics(targetRecord);
                    if (options.focus) {
                        targetRecord.element.focusItem(itemId);
                    }
                    this.flashList(targetListId);
                    this.refreshSidebar();

                    if (this.repository) {
                        const beforeId = options.beforeId ?? fallbackBeforeId;
                        const promise = this.repository.moveTask(
                            sourceListId,
                            targetListId,
                            itemId,
                            {
                                snapshot,
                                beforeId,
                                afterId: options.afterId,
                            },
                        );
                        this.runRepositoryOperation(promise);
                    }
                }

                refreshMetrics(record) {
                    if (!record) return;
                    record.totalCount = record.element.getTotalItemCount();
                    record.matchCount = record.element.getSearchMatchCount();
                }

                refreshSidebar() {
                    const data = this.getSidebarListData();
                    this.sidebar.setLists(data, {
                        activeListId: this.activeListId,
                        searchQuery: this.searchQuery,
                    });
                }

                getSidebarListData() {
                    const searchActive = this.isSearchMode();
                    return this.listOrder
                        .map((id) => {
                            const record = this.listRegistry.get(id);
                            if (!record) return null;
                            return {
                                id: record.id,
                                name: record.name,
                                totalCount: record.totalCount,
                                matchCount: record.matchCount,
                                countLabel: searchActive
                                    ? this.formatMatchCount(record.matchCount)
                                    : this.formatTotalCount(record.totalCount),
                            };
                        })
                        .filter(Boolean);
                }

                updateSearchMode() {
                    const searchMode = this.isSearchMode();
                    if (this.mainElement) {
                        this.mainElement.classList.toggle("search-mode", searchMode);
                    }
                    this.updateListVisibility();
                }

                updateListVisibility() {
                    const searchMode = this.isSearchMode();
                    this.listOrder.forEach((id) => {
                        const record = this.listRegistry.get(id);
                        if (!record) return;
                        const isActive = id === this.activeListId;
                        const shouldShow = searchMode || isActive;
                        record.wrapper.classList.toggle("is-visible", shouldShow);
                        record.wrapper.classList.toggle("is-active", isActive);
                    });
                }

                updateMainHeading() {
                    if (!this.mainTitleEl) return;
                    if (this.isSearchMode()) {
                        if (this.searchQuery.trim().length) {
                            this.mainTitleEl.textContent = `Search: "${this.searchQuery}"`;
                        } else {
                            this.mainTitleEl.textContent = "Search Results";
                        }
                        return;
                    }
                    const active = this.listRegistry.get(this.activeListId);
                    this.mainTitleEl.textContent = active ? active.name : "Task Collections";
                }

                flashList(listId) {
                    const record = this.listRegistry.get(listId);
                    if (!record) return;
                    if (record.flashTimer) {
                        clearTimeout(record.flashTimer);
                    }
                    record.wrapper.classList.add("list-section--flash");
                    record.flashTimer = setTimeout(() => {
                        record.wrapper.classList.remove("list-section--flash");
                        record.flashTimer = null;
                    }, 600);
                }

                isSearchMode() {
                    return this.searchQuery.trim().length > 0;
                }

                formatMatchCount(count) {
                    if (!count) return "No matches";
                    return count === 1 ? "1 match" : `${count} matches`;
                }

                formatTotalCount(count) {
                    if (!count) return "Empty";
                    return count === 1 ? "1" : `${count}`;
                }
            }

            document.addEventListener("DOMContentLoaded", () => {
                (async () => {
                    const appRoot = document.querySelector("[data-role='lists-app']");
                    if (!appRoot) return;
                    const sidebarElement = appRoot.querySelector("[data-role='sidebar']");
                    const mainElement = appRoot.querySelector("[data-role='main']");
                    const listsContainer = appRoot.querySelector("[data-role='lists-container']");
                    const mainTitleElement =
                        mainElement?.querySelector("[data-role='active-list-title']") ?? null;
                    const moveDialogElement = document.querySelector("[data-role='move-dialog']");
                    await resetPersistentStorageIfNeeded();
                    const repository = new ListRepository();
                    await ensureDemoData(repository, SEED_LIST_CONFIGS).catch(() => {});
                    const app = new ListsApp({
                        sidebarElement,
                        mainElement,
                        listsContainer,
                        mainTitleElement,
                        moveDialogElement,
                        listRepository: repository,
                    });
                    await app.initialize();
                    window.listsApp = app;
                })().catch(() => {});
            });
        </script>
    </body>
</html>
