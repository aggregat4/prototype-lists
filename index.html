<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Prototype Lists</title>
<style>
  body {
    font-family: Inter, sans-serif;
    padding: 0;
    font-size: 18px;
  }
  main {
    max-width: 800px;
    margin: 0 auto;
  }
  ol.tasklist {
    padding: 12px;
    margin: 0;
    list-style-type: none;
    background-color: #f5f5f5;
  }
  .tasklist li {
    margin-bottom: 10px;
    background-color: white;
    border: 1px solid #a1a1a1;
    border-bottom: 2px solid #4d4d4d;
    display: flex;
    align-items: center;
    /* smooth reflow for siblings (FLIP) */
    position: relative;
    will-change: transform;
  }
  .tasklist li .done-toggle {
    margin: 0 14px 0 12px;
    width: 20px;
    height: 20px;
    flex-shrink: 0;
    cursor: pointer;
  }
  .tasklist li .done-toggle:focus-visible {
    outline: 2px solid #4d4d4d;
    outline-offset: 2px;
  }
  .tasklist li .done-toggle:checked + .text {
    text-decoration: line-through;
    color: #7a7a7a;
  }
  .tasklist li .text {
    padding: 8px 6px;
    flex: 1;
  }
  .tasklist li.editing .text {
    background: #f0f0f0;
    outline: 2px solid rgba(77,77,77,0.2);
    outline-offset: 2px;
  }
  .tasklist li .handle {
    margin-left: auto;
    padding: 8px;
    cursor: grab;
    color: #999;
    user-select: none;
  }
  .tasklist li .handle:active { cursor: grabbing; }
  .tasklist > li:active { cursor: grabbing; }

  /* The floating dragged item */
  .tasklist > li.dragging {
    position: fixed;      /* out of flow while dragging */
    z-index: 1000;
    pointer-events: none; /* don't intercept */
    box-shadow: 0 8px 24px rgba(0,0,0,.18);
    opacity: 0.98;
    color: inherit;
    background: white;
    border-color: #a1a1a1;
  }

  /* Placeholder reserves space where the item would be */
  .tasklist li.placeholder {
    background: transparent;
    border: 2px dashed #bbb;
    height: 0;              /* set inline */
    margin-bottom: 10px;    /* match spacing */
  }

  /* slide animation (FLIP) */
  .flip-animating {
    transition: transform 140ms ease;
  }

  /* subtle drop wiggle animation */
  .drop-animation {
    animation: dropSlide 0.3s ease-out;
  }
  @keyframes dropSlide {
    0%   { transform: translateX(-8px); opacity: 0.7; }
    50%  { transform: translateX(8px);  opacity: 0.7; }
    100% { transform: translateX(0);    opacity: 1; }
  }
</style>

</head>
<body>

  <main>
    <ol class="tasklist">
      <li draggable="true"><input type="checkbox" class="done-toggle" /><span class="text">Refill the bird feeder before the sparrows file another formal request.</span><span class="handle">≡</span></li>
      <li draggable="true"><input type="checkbox" class="done-toggle" /><span class="text">Check the fridge light still turns off, preferably without crawling inside again.</span><span class="handle">≡</span></li>
      <li draggable="true"><input type="checkbox" class="done-toggle" /><span class="text">Return the umbrella to the hallway, where it insists it lives.</span><span class="handle">≡</span></li>
      <li draggable="true"><input type="checkbox" class="done-toggle" /><span class="text">Water the fern before it submits another strongly worded letter to the radiator.</span><span class="handle">≡</span></li>
      <li draggable="true"><input type="checkbox" class="done-toggle" /><span class="text">Update the shopping list to include milk, bread, and a moderately sensible hat.</span><span class="handle">≡</span></li>
      <li draggable="true"><input type="checkbox" class="done-toggle" /><span class="text">Verify that the kettle boils water and not, as it occasionally attempts, good intentions.</span><span class="handle">≡</span></li>
      <li draggable="true"><input type="checkbox" class="done-toggle" /><span class="text">Organize the cutlery drawer so the forks don't keep holding union meetings.</span><span class="handle">≡</span></li>
      <li draggable="true"><input type="checkbox" class="done-toggle" /><span class="text">Empty the dishwasher before it begins drafting poetry about neglect.</span><span class="handle">≡</span></li>
      <li draggable="true"><input type="checkbox" class="done-toggle" /><span class="text">Set the alarm clock, reminding it gently that no one enjoys its personality.</span><span class="handle">≡</span></li>
      <li draggable="true"><input type="checkbox" class="done-toggle" /><span class="text">Take the bins out, though they are increasingly insistent they'd rather stay in.</span><span class="handle">≡</span></li>
      <li draggable="true"><input type="checkbox" class="done-toggle" /><span class="text">Test the smoke detector by asking it politely to explain its worldview.</span><span class="handle">≡</span></li>
      <li draggable="true"><input type="checkbox" class="done-toggle" /><span class="text">Send an email to the electricity meter thanking it for its tireless blinking.</span><span class="handle">≡</span></li>
      <li draggable="true"><input type="checkbox" class="done-toggle" /><span class="text">Sharpen pencils so they feel prepared for anything, including international diplomacy.</span><span class="handle">≡</span></li>
      <li draggable="true"><input type="checkbox" class="done-toggle" /><span class="text">Update the calendar to reflect the current year, not the one the cat prefers.</span><span class="handle">≡</span></li>
      <li draggable="true"><input type="checkbox" class="done-toggle" /><span class="text">Polish the windows until they are clear about their long-term career goals.</span><span class="handle">≡</span></li>
      <li draggable="true"><input type="checkbox" class="done-toggle" /><span class="text">Check the washing machine for socks that have declared independence.</span><span class="handle">≡</span></li>
      <li draggable="true"><input type="checkbox" class="done-toggle" /><span class="text">Restock the biscuit tin before negotiations with visitors turn awkward.</span><span class="handle">≡</span></li>
      <li draggable="true"><input type="checkbox" class="done-toggle" /><span class="text">Feed the goldfish, who has recently taken to sighing at odd intervals.</span><span class="handle">≡</span></li>
      <li draggable="true"><input type="checkbox" class="done-toggle" /><span class="text">Write down the Wi-Fi password in case it decides to change its name again.</span><span class="handle">≡</span></li>
      <li draggable="true"><input type="checkbox" class="done-toggle" /><span class="text">Vacuum the carpet before it develops further geological features.</span><span class="handle">≡</span></li>
    </ol>
  </main>

  <script>
  // DraggableBehavior - drag & drop with floating dragged item and an optional animator
  // It assumes it is being applied to a list container as some of the internals assume
  // li elements
  class DraggableBehavior {
    constructor(container, options = {}) {
      this.container = container;
      this.options = {
        handleClass: 'handle',
        threshold: 10,
        onReorder: null,
        animator: null,
        ...options
      };
      this.dragging = null;
      this.touchStartY = 0;
      this.touchStartX = 0;
      this.isTouchDragging = false;
      this.rafId = null;
      this.cachedItems = null;
      this.enabled = false;
      this.placeholder = null;
      this.originalPosition = null;
      this.pointerOffsetY = 0;
      this.pointerOffsetX = 0;
      this.animator = this.options.animator;

      // bind handlers once so removeEventListeners works reliably
      this._onDragStart = this.handleDragStart.bind(this);
      this._onDragEnd   = this.handleDragEnd.bind(this);
      this._onDragOver  = this.handleDragOver.bind(this);
      this._onDrop      = this.handleDrop.bind(this);

      this._onTouchStart = this.handleTouchStart.bind(this);
      this._onTouchMove  = this.handleTouchMove.bind(this);
      this._onTouchEnd   = this.handleTouchEnd.bind(this);
      
      this.deferFloatingInit = false;   // for Chrome: delay init on mouse DnD
      this._pendingInitCoords = null;   // { x, y } to start floating later
    }

    enable() {
      if (this.enabled) return;
      this.enabled = true;
      this.setupEventListeners();
    }

    disable() {
      if (!this.enabled) return;
      this.enabled = false;
      this.removeEventListeners();
    }

    destroy() {
      this.disable();
      this.container = null;
    }

    setupEventListeners() {
      // Mouse events
      this.container.addEventListener('dragstart', this._onDragStart);
      this.container.addEventListener('dragend', this._onDragEnd);
      this.container.addEventListener('dragover', this._onDragOver);
      this.container.addEventListener('drop', this._onDrop);

      // Touch events
      this.container.addEventListener('touchstart', this._onTouchStart, { passive: true });
      this.container.addEventListener('touchmove', this._onTouchMove, { passive: false });
      this.container.addEventListener('touchend', this._onTouchEnd, { passive: true });
    }

    removeEventListeners() {
      this.container.removeEventListener('dragstart', this._onDragStart);
      this.container.removeEventListener('dragend', this._onDragEnd);
      this.container.removeEventListener('dragover', this._onDragOver);
      this.container.removeEventListener('drop', this._onDrop);

      this.container.removeEventListener('touchstart', this._onTouchStart);
      this.container.removeEventListener('touchmove', this._onTouchMove);
      this.container.removeEventListener('touchend', this._onTouchEnd);
    }

    handleDragStart(e) {
      const li = e.target.closest('li');
      if (!li) return;

      // Mark that we must delay floating/placeholder until the first dragover
      // we do this for desktop browsers, specifically Chrome will abort a drag
      // if we create a placeholder element with document.createElement before
      // the first dragover event. This workaround delays creating the placeholder
      // until that moment
      this.deferFloatingInit = true;
      this._pendingInitCoords = { x: e.clientX, y: e.clientY };

      // Just record the drag start; NO DOM changes here
      this.startDrag(li /* no coords now */);

      // suppress default ghost image
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', '');
      const emptyImg = document.createElement('img');
      emptyImg.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAUEBAAAACwAAAAAAQABAAACAkQBADs=';
      e.dataTransfer.setDragImage(emptyImg, 0, 0);
    }

    handleDragEnd() {
      this.endDrag();
    }

    handleDragOver(e) {
      e.preventDefault();

      // If we deferred (Chrome), do the first-time init now
      if (this.dragging && this.deferFloatingInit) {
        this.deferFloatingInit = false;
        const p = this._pendingInitCoords || { x: e.clientX, y: e.clientY };
        this.beginFloating(p.x, p.y);      // create placeholder + make item fixed
        this._pendingInitCoords = null;
      }

      // Now it’s safe to animate & move
      this.updateFloating(e.clientX, e.clientY);
      this.debouncedDragOver(e.clientY);
      e.dataTransfer.dropEffect = 'move';
    }


    handleDrop(e) {
      e.preventDefault();
      this.drop(e.clientY);
      this.endDrag();
    }

    // Touch event handlers
    handleTouchStart(e) {
      if (!e.target.classList.contains(this.options.handleClass)) return;
      const li = e.target.closest('li');
      if (!li) return;
      this.touchStartY = e.touches[0].clientY;
      this.touchStartX = e.touches[0].clientX;
      this.isTouchDragging = false;
    }

    handleTouchMove(e) {
      if (!e.target.classList.contains(this.options.handleClass)) return;
      // Only start dragging if the touch distance is greater than the threshold
      // This prevents accidental dragging when scrolling or tapping
      if (!this.isTouchDragging) {
        const deltaY = Math.abs(e.touches[0].clientY - this.touchStartY);
        const deltaX = Math.abs(e.touches[0].clientX - this.touchStartX);
        const totalDistance = Math.hypot(deltaX, deltaY);
        if (totalDistance > this.options.threshold) {
          const li = e.target.closest('li');
          if (li) {
            this.isTouchDragging = true;
            this.startDrag(li, e.touches[0].clientX, e.touches[0].clientY);
            if (e.cancelable) e.preventDefault();
          }
        }
      } else if (this.dragging) {
        if (e.cancelable) e.preventDefault();
        this.updateFloating(e.touches[0].clientX, e.touches[0].clientY);
        this.debouncedDragOver(e.touches[0].clientY);
      }
    }

    handleTouchEnd(e) {
      if (this.isTouchDragging && this.dragging) {
        this.drop(e.changedTouches[0].clientY);
        this.endDrag();
      }
    }

    // Core drag logic
    startDrag(li, startClientX = null, startClientY = null) {
      this.dragging = li;
      this.originalPosition = this.getIndex(li);
      this.invalidateItemsCache();

      // For touch (or any non-deferred start), we may be passed coords:
      if (!this.deferFloatingInit && startClientX != null && startClientY != null) {
        this.beginFloating(startClientX, startClientY);
      }
    }

    endDrag() {
      if (!this.dragging) return;

      // If drag was cancelled (no drop), restore to original position via placeholder
      if (this.originalPosition !== null && this.placeholder) {
        const children = Array.from(this.container.children).filter(n => n !== this.dragging);
        const targetIndex = Math.min(this.originalPosition, children.length);
        const target = children[targetIndex] || null;
        this.container.insertBefore(this.placeholder, target);
      }

      // Place dragged item at placeholder (drop() already positioned placeholder)
      if (this.placeholder) {
        this.container.insertBefore(this.dragging, this.placeholder);
      }

      this.endFloating();

      this.dragging = null;
      this.isTouchDragging = false;
      this.originalPosition = null;
      this.invalidateItemsCache();
    }

    dragOver(clientY) {
      if (!this.dragging) return;
      const after = this.getDropTarget(clientY);
      this.moveDraggedElement(after);
    }

    debouncedDragOver(clientY) {
      if (this.rafId) cancelAnimationFrame(this.rafId);
      this.rafId = requestAnimationFrame(() => {
        this.dragOver(clientY);
        this.rafId = null;
      });
    }

    drop(clientY) {
      if (!this.dragging) return;
      const after = this.getDropTarget(clientY);
      // Move placeholder to its final spot
      this.moveDraggedElement(after);
      // mark as successfully dropped so endDrag won't restore
      this.originalPosition = null;
      // Save a reference to the dragged element so we can access it after the animation
      const draggedRef = this.dragging;
      // give a short wiggle once it lands (after endDrag puts it in place)
      draggedRef.classList.add('drop-animation');
      setTimeout(() => draggedRef.classList.remove('drop-animation'), 300);
      // notify reorder listeners
      if (this.options.onReorder) {
        const items = Array.from(this.container.children);
        const toIndex = items.indexOf(this.placeholder);
        const fromIndex = this.getIndex(draggedRef);
        this.options.onReorder(fromIndex, toIndex);
      }
    }

    // Floating item + placeholder
    createPlaceholder(heightPx) {
      const ph = document.createElement('li');
      ph.className = 'placeholder';
      ph.style.height = `${heightPx}px`;
      return ph;
    }

    beginFloating(eClientX, eClientY) {
      const li = this.dragging;
      const rect = li.getBoundingClientRect();

      // Insert placeholder at current location
      this.placeholder = this.createPlaceholder(rect.height);
      this.container.insertBefore(this.placeholder, li);

      // Fix the dragged element to the viewport (use existing node)
      li.style.width = rect.width + 'px';
      li.style.left = rect.left + 'px';
      li.style.top = rect.top + 'px';
      li.classList.add('dragging');

      // Remember pointer offset inside the element for a natural grip
      this.pointerOffsetY = (eClientY != null) ? (eClientY - rect.top) : rect.height / 2;
      this.pointerOffsetX = (eClientX != null) ? (eClientX - rect.left) : 16;
    }

    updateFloating(eClientX, eClientY) {
      if (!this.dragging) return;
      const y = eClientY - this.pointerOffsetY;
      this.dragging.style.top = y + 'px';
    }

    endFloating() {
      if (!this.dragging) return;
      const li = this.dragging;
      li.classList.remove('dragging');
      li.style.position = '';
      li.style.top = '';
      li.style.left = '';
      li.style.width = '';
      li.style.zIndex = '';
      li.style.pointerEvents = '';
      li.style.boxShadow = '';
      if (this.placeholder?.parentNode) {
        this.placeholder.parentNode.removeChild(this.placeholder);
      }
      this.placeholder = null;
    }

    getDropTarget(mouseY) {
      if (!this.cachedItems) {
        // exclude dragging item and placeholder from the search set
        this.cachedItems = [...this.container.querySelectorAll('li:not(.dragging):not(.placeholder)')];
      }
      if (this.cachedItems.length === 0) return null;

      let left = 0;
      let right = this.cachedItems.length;

      while (left < right) {
        const mid = Math.floor((left + right) / 2);
        const rect = this.cachedItems[mid].getBoundingClientRect();
        const midY = rect.top + rect.height / 2;

        if (mouseY < midY) {
          right = mid;
        } else {
          left = mid + 1;
        }
      }

      return left < this.cachedItems.length ? this.cachedItems[left] : null;
    }

    getIndex(element) {
      return Array.from(this.container.children).indexOf(element);
    }

    invalidateItemsCache() {
      this.cachedItems = null;
    }

    // Move the placeholder (not the dragged element) and hand over animations
    moveDraggedElement(after) {
      if (!this.dragging || !this.placeholder) return;

      const prev = this.animator?.snapshot(this.container, this.dragging);

      if (after == null) {
        this.container.appendChild(this.placeholder);
      } else {
        this.container.insertBefore(this.placeholder, after);
      }

      this.invalidateItemsCache();
      // Apply the configured animation (if any) immediately so the browser
      // never paints the target layout before we invert it, avoiding flicker.
      this.animator?.play(this.container, this.dragging, prev);
    }
  }

  // FLIPAnimator isolates the animation concerns from the drag logic so a
  // different animator can be supplied if desired.
  class FlipAnimator {
    snapshot(container, dragging) {
      const map = new Map();
      [...container.querySelectorAll('li')].forEach(li => {
        if (li !== dragging) {
          map.set(li, li.getBoundingClientRect().top);
        }
      });
      return map;
    }

    play(container, dragging, prevTops) {
      if (!prevTops) return;
      [...container.querySelectorAll('li')].forEach(li => {
        if (li === dragging) return;
        const prevTop = prevTops.get(li);
        if (prevTop == null) return;

        const nowTop = li.getBoundingClientRect().top;
        const dy = prevTop - nowTop;
        if (dy === 0) return;

        li.style.transform = `translateY(${dy}px)`;
        // force reflow so the browser picks up the initial transform before
        // transitioning back to zero
        // eslint-disable-next-line no-unused-expressions
        li.offsetHeight;

        li.classList.add('flip-animating');
        li.style.transform = 'translateY(0)';

        const done = () => {
          li.classList.remove('flip-animating');
          li.style.transform = '';
          li.removeEventListener('transitionend', done);
        };
        li.addEventListener('transitionend', done, { once: true });
      });
    }
  }

  // InlineTextEditor manages single-click editing for list item text content.
  class InlineTextEditor {
    constructor(list) {
      this.list = list;
      this.editingEl = null;

      this.handleClick = this.handleClick.bind(this);
      this.handleBlur = this.handleBlur.bind(this);
      this.handleKeyDown = this.handleKeyDown.bind(this);

      this.list.addEventListener('click', this.handleClick);
    }

    destroy() {
      this.list.removeEventListener('click', this.handleClick);
      if (this.editingEl) {
        this.finishEditing(this.editingEl);
      }
      this.list = null;
    }

    handleClick(e) {
      const text = e.target.closest('.text');
      if (!text || !this.list.contains(text)) return;
      this.startEditing(text, e);
    }

    startEditing(textEl, triggerEvent = null) {
      if (this.editingEl === textEl) return;

      if (this.editingEl) {
        this.finishEditing(this.editingEl);
      }

      this.editingEl = textEl;
      const li = textEl.closest('li');
      if (li) {
        if (li.getAttribute('draggable') !== 'false') {
          li.dataset.wasDraggable = 'true';
          li.setAttribute('draggable', 'false');
        }
        li.classList.add('editing');
      }

      textEl.setAttribute('contenteditable', 'true');
      textEl.setAttribute('spellcheck', 'false');
      textEl.addEventListener('blur', this.handleBlur);
      textEl.addEventListener('keydown', this.handleKeyDown);

      // focus after listeners to ensure we capture the blur that follows
      textEl.focus();
      this.placeCaret(textEl, triggerEvent);
    }

    placeCaret(element, triggerEvent) {
      const selection = window.getSelection();
      if (!selection) return;
      // Try to put the caret at the click position
      let range = null;
      if (triggerEvent && typeof triggerEvent.clientX === 'number' && typeof triggerEvent.clientY === 'number') {
        const doc = element.ownerDocument;
        if (doc.caretPositionFromPoint) {
          const pos = doc.caretPositionFromPoint(triggerEvent.clientX, triggerEvent.clientY);
          if (pos) {
            range = doc.createRange();
            range.setStart(pos.offsetNode, pos.offset);
            range.collapse(true);
          }
        } else if (doc.caretRangeFromPoint) {
          range = doc.caretRangeFromPoint(triggerEvent.clientX, triggerEvent.clientY);
          if (range && !range.collapsed) {
            range.collapse(true);
          }
        }

        if (range && !element.contains(range.startContainer)) {
          range = null;
        }
      }

      if (!range) {
        // If that fails, just select the entire content
        range = element.ownerDocument.createRange();
        range.selectNodeContents(element);
        range.collapse(false);
      }

      selection.removeAllRanges();
      selection.addRange(range);
    }

    handleBlur(e) {
      this.finishEditing(e.target);
    }

    handleKeyDown(e) {
      if (e.key === 'Enter' || e.key === 'Escape') {
        e.preventDefault();
        e.target.blur();
      }
    }

    finishEditing(textEl) {
      if (!textEl || this.editingEl !== textEl) return;

      textEl.removeEventListener('blur', this.handleBlur);
      textEl.removeEventListener('keydown', this.handleKeyDown);
      textEl.removeAttribute('contenteditable');
      textEl.removeAttribute('spellcheck');

      const li = textEl.closest('li');
      if (li) {
        li.classList.remove('editing');
        if (li.dataset.wasDraggable) {
          li.setAttribute('draggable', 'true');
          delete li.dataset.wasDraggable;
        }
      }

      this.editingEl = null;
    }
  }

  // TodoListController wires drag/drop + inline editing to a list element.
  class TodoListController {
    constructor(listElement) {
      this.list = listElement;
      this.dragBehavior = null;
      this.inlineEditor = null;
      this.setup();
    }

    setup() {
      this.dragBehavior = new DraggableBehavior(this.list, {
        handleClass: 'handle',
        onReorder: (fromIndex, toIndex) => {
          console.log(`Moved item from ${fromIndex} to ${toIndex}`);
          // Emit custom event for external listeners
          this.list.dispatchEvent(new CustomEvent('reorder', {
            detail: { fromIndex, toIndex }
          }));
        },
        animator: new FlipAnimator()
      });
      this.dragBehavior.enable();

      this.inlineEditor = new InlineTextEditor(this.list);
    }

    destroy() {
      this.dragBehavior?.destroy();
      this.inlineEditor?.destroy();
    }
  }

  const todoListControllers = [];
  document.querySelectorAll('ol.tasklist').forEach(listEl => {
    todoListControllers.push(new TodoListController(listEl));
  });
</script>
</body>
</html>
