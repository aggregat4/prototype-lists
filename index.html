<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Prototype Lists</title>
<style>
  body {
    font-family: Inter, sans-serif;
    padding: 0;
    font-size: 18px;
  }
  main {
    max-width: 800px;
    margin: 0 auto;
    /* padding: 1rem; */
  }
  ol.tasklist {
    padding: 12px;
    margin: 0;
    list-style-type: none;
    background-color: #f5f5f5;
  }
  .tasklist li {
    margin-bottom: 10px;
    background-color: white;
    border: 1px solid #a1a1a1;
    border-bottom: 2px solid #4d4d4d;
    display: flex;
    align-items: center;
  }
  .tasklist li .text {
    padding: 8px 6px;
  }
  .tasklist li .handle {
    margin-left: auto;
    padding: 8px;
    cursor: grab;
    color: #999;
    user-select: none;
  }
  .tasklist li .handle:active { cursor: grabbing; }
  .tasklist > li:active { cursor: grabbing; }
  .tasklist > li.dragging { opacity: .6; }
  /* subtle drop indicators */
  .tasklist > li.drop-before { box-shadow: 0 -2px 0 0 currentColor inset; }
  .tasklist > li.drop-after  { box-shadow: 0  2px 0 0 currentColor inset; }
  
  /* drop animation */
  .tasklist > li.drop-animation {
    animation: dropSlide 0.3s ease-out;
  }
  
  @keyframes dropSlide {
    0% {
      transform: translateX(-8px);
      opacity: 0.7;
    }
    50% {
      transform: translateX(8px);
      opacity: 0.7;
    }
    100% {
      transform: translateX(0);
      opacity: 1;
    }
  }
</style>

</head>
<body>

  <main>
    <ol id="tasks" class="tasklist">
      <li draggable="true"><span class="text">Refill the bird feeder before the sparrows file another formal request.</span><span class="handle">≡</span></li>
      <li draggable="true"><span class="text">Check the fridge light still turns off, preferably without crawling inside again.</span><span class="handle">≡</span></li>
      <li draggable="true"><span class="text">Return the umbrella to the hallway, where it insists it lives.</span><span class="handle">≡</span></li>
      <li draggable="true"><span class="text">Water the fern before it submits another strongly worded letter to the radiator.</span><span class="handle">≡</span></li>
      <li draggable="true"><span class="text">Update the shopping list to include milk, bread, and a moderately sensible hat.</span><span class="handle">≡</span></li>
      <li draggable="true"><span class="text">Verify that the kettle boils water and not, as it occasionally attempts, good intentions.</span><span class="handle">≡</span></li>
      <li draggable="true"><span class="text">Organize the cutlery drawer so the forks don't keep holding union meetings.</span><span class="handle">≡</span></li>
      <li draggable="true"><span class="text">Empty the dishwasher before it begins drafting poetry about neglect.</span><span class="handle">≡</span></li>
      <li draggable="true"><span class="text">Set the alarm clock, reminding it gently that no one enjoys its personality.</span><span class="handle">≡</span></li>
      <li draggable="true"><span class="text">Take the bins out, though they are increasingly insistent they'd rather stay in.</span><span class="handle">≡</span></li>
      <li draggable="true"><span class="text">Test the smoke detector by asking it politely to explain its worldview.</span><span class="handle">≡</span></li>
      <li draggable="true"><span class="text">Send an email to the electricity meter thanking it for its tireless blinking.</span><span class="handle">≡</span></li>
      <li draggable="true"><span class="text">Sharpen pencils so they feel prepared for anything, including international diplomacy.</span><span class="handle">≡</span></li>
      <li draggable="true"><span class="text">Update the calendar to reflect the current year, not the one the cat prefers.</span><span class="handle">≡</span></li>
      <li draggable="true"><span class="text">Polish the windows until they are clear about their long-term career goals.</span><span class="handle">≡</span></li>
      <li draggable="true"><span class="text">Check the washing machine for socks that have declared independence.</span><span class="handle">≡</span></li>
      <li draggable="true"><span class="text">Restock the biscuit tin before negotiations with visitors turn awkward.</span><span class="handle">≡</span></li>
      <li draggable="true"><span class="text">Feed the goldfish, who has recently taken to sighing at odd intervals.</span><span class="handle">≡</span></li>
      <li draggable="true"><span class="text">Write down the Wi-Fi password in case it decides to change its name again.</span><span class="handle">≡</span></li>
      <li draggable="true"><span class="text">Vacuum the carpet before it develops further geological features.</span><span class="handle">≡</span></li>
    </ol>
  </main>

  <script>
  const list = document.getElementById('tasks');
  let dragging = null;
  let touchStartY = 0;
  let touchStartX = 0;
  let isTouchDragging = false;
  let rafId = null;

  // Shared functions
  function startDrag(li) {
    dragging = li;
    li.classList.add('dragging');
  }

  function endDrag() {
    cleanupIndicators();
    dragging?.classList.remove('dragging');
    dragging = null;
    isTouchDragging = false;
  }

  function handleDragOver(clientY) {
    if (!dragging) return;
    const after = getDropTarget(list, clientY);
    cleanupIndicators();
    if (after == null) {
      list.lastElementChild?.classList.add('drop-before');
    } else {
      after.classList.add('drop-after');
    }
  }

  // Debounce drag over events to 60fps max using requestAnimationFrame
  // Prevents excessive DOM queries and getBoundingClientRect() calls during drag
  function debouncedHandleDragOver(clientY) {
    if (rafId) cancelAnimationFrame(rafId);
    rafId = requestAnimationFrame(() => {
      handleDragOver(clientY);
      rafId = null;
    });
  }

  function handleDrop(clientY) {
    if (!dragging) return;
    const after = getDropTarget(list, clientY);
    if (after == null) list.appendChild(dragging);
    else list.insertBefore(dragging, after);
    cleanupIndicators();
    
    // Trigger drop animation
    dragging.classList.add('drop-animation');
    const animatedDragging = dragging;
    setTimeout(() => animatedDragging.classList.remove('drop-animation'), 300);
  }

  function getDropTarget(container, mouseY) {
    const items = [...container.querySelectorAll('li:not(.dragging)')];
    if (items.length === 0) return null;
    
    // Binary search for insertion point
    let left = 0;
    let right = items.length;
    
    while (left < right) {
      const mid = Math.floor((left + right) / 2);
      const rect = items[mid].getBoundingClientRect();
      const midY = rect.top + rect.height / 2;
      
      if (mouseY < midY) {
        right = mid;
      } else {
        left = mid + 1;
      }
    }
    
    // Return the item at the insertion point, or null for append at end
    return left < items.length ? items[left] : null;
  }

  // Mouse events
  list.addEventListener('dragstart', (e) => {
    const li = e.target.closest('li');
    if (!li) return;
    startDrag(li);
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/plain', '');
  });

  list.addEventListener('dragend', endDrag);

  list.addEventListener('dragover', (e) => {
    e.preventDefault();
    debouncedHandleDragOver(e.clientY);
    e.dataTransfer.dropEffect = 'move';
  });

  list.addEventListener('drop', (e) => {
    e.preventDefault();
    handleDrop(e.clientY);
    endDrag();
  });

  function cleanupIndicators() {
    list.querySelectorAll('.drop-before, .drop-after').forEach(li => {
      li.classList.remove('drop-before', 'drop-after');
    });
  }

  // Touch events
  list.addEventListener('touchstart', (e) => {
    if (!e.target.classList.contains('handle')) return;
    const li = e.target.closest('li');
    if (!li) return;
    touchStartY = e.touches[0].clientY;
    touchStartX = e.touches[0].clientX;
    isTouchDragging = false;
  }, { passive: true });

  list.addEventListener('touchmove', (e) => {
    if (!e.target.classList.contains('handle')) return;
    const deltaY = Math.abs(e.touches[0].clientY - touchStartY);
    const deltaX = Math.abs(e.touches[0].clientX - touchStartX);
    const totalDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    
    if (!isTouchDragging && totalDistance > 10) {
      const li = e.target.closest('li');
      if (li) {
        isTouchDragging = true;
        startDrag(li);
        e.preventDefault();
      }
    } else if (isTouchDragging && dragging) {
      e.preventDefault();
      debouncedHandleDragOver(e.touches[0].clientY);
    }
  }, { passive: false });

  list.addEventListener('touchend', (e) => {
    if (isTouchDragging && dragging) {
      handleDrop(e.changedTouches[0].clientY);
      endDrag();
    }
  }, { passive: true });
</script>
</body>
</html>
