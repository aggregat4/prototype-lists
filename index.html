<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Prototype Lists</title>
<style>
  body {
    font-family: Inter, sans-serif;
    padding: 0;
    font-size: 18px;
  }
  main {
    max-width: 800px;
    margin: 0 auto;
    /* padding: 1rem; */
  }
  ol.tasklist {
    padding: 12px;
    margin: 0;
    list-style-type: none;
    background-color: #f5f5f5;
  }
  .tasklist li {
    margin-bottom: 10px;
    background-color: white;
    border: 1px solid #a1a1a1;
    border-bottom: 2px solid #4d4d4d;
    display: flex;
    align-items: center;
  }
  .tasklist li .text {
    padding: 8px 6px;
  }
  .tasklist li .handle {
    margin-left: auto;
    padding: 8px;
    cursor: grab;
    color: #999;
    user-select: none;
  }
  .tasklist li .handle:active { cursor: grabbing; }
  .tasklist > li:active { cursor: grabbing; }
  .tasklist > li.dragging { 
    /* opacity: .6;  */
    background-color: #4d4d4d;
    /* border: 2px dotted white; */
    color: white;
    /* display: none; */
  }
  
  /* drop animation */
  .tasklist > li.drop-animation {
    animation: dropSlide 0.3s ease-out;
  }
  
  @keyframes dropSlide {
    0% {
      transform: translateX(-8px);
      opacity: 0.7;
    }
    50% {
      transform: translateX(8px);
      opacity: 0.7;
    }
    100% {
      transform: translateX(0);
      opacity: 1;
    }
  }
</style>

</head>
<body>

  <main>
    <ol is="todo-list" class="tasklist">
      <li draggable="true"><span class="text">Refill the bird feeder before the sparrows file another formal request.</span><span class="handle">≡</span></li>
      <li draggable="true"><span class="text">Check the fridge light still turns off, preferably without crawling inside again.</span><span class="handle">≡</span></li>
      <li draggable="true"><span class="text">Return the umbrella to the hallway, where it insists it lives.</span><span class="handle">≡</span></li>
      <li draggable="true"><span class="text">Water the fern before it submits another strongly worded letter to the radiator.</span><span class="handle">≡</span></li>
      <li draggable="true"><span class="text">Update the shopping list to include milk, bread, and a moderately sensible hat.</span><span class="handle">≡</span></li>
      <li draggable="true"><span class="text">Verify that the kettle boils water and not, as it occasionally attempts, good intentions.</span><span class="handle">≡</span></li>
      <li draggable="true"><span class="text">Organize the cutlery drawer so the forks don't keep holding union meetings.</span><span class="handle">≡</span></li>
      <li draggable="true"><span class="text">Empty the dishwasher before it begins drafting poetry about neglect.</span><span class="handle">≡</span></li>
      <li draggable="true"><span class="text">Set the alarm clock, reminding it gently that no one enjoys its personality.</span><span class="handle">≡</span></li>
      <li draggable="true"><span class="text">Take the bins out, though they are increasingly insistent they'd rather stay in.</span><span class="handle">≡</span></li>
      <li draggable="true"><span class="text">Test the smoke detector by asking it politely to explain its worldview.</span><span class="handle">≡</span></li>
      <li draggable="true"><span class="text">Send an email to the electricity meter thanking it for its tireless blinking.</span><span class="handle">≡</span></li>
      <li draggable="true"><span class="text">Sharpen pencils so they feel prepared for anything, including international diplomacy.</span><span class="handle">≡</span></li>
      <li draggable="true"><span class="text">Update the calendar to reflect the current year, not the one the cat prefers.</span><span class="handle">≡</span></li>
      <li draggable="true"><span class="text">Polish the windows until they are clear about their long-term career goals.</span><span class="handle">≡</span></li>
      <li draggable="true"><span class="text">Check the washing machine for socks that have declared independence.</span><span class="handle">≡</span></li>
      <li draggable="true"><span class="text">Restock the biscuit tin before negotiations with visitors turn awkward.</span><span class="handle">≡</span></li>
      <li draggable="true"><span class="text">Feed the goldfish, who has recently taken to sighing at odd intervals.</span><span class="handle">≡</span></li>
      <li draggable="true"><span class="text">Write down the Wi-Fi password in case it decides to change its name again.</span><span class="handle">≡</span></li>
      <li draggable="true"><span class="text">Vacuum the carpet before it develops further geological features.</span><span class="handle">≡</span></li>
    </todo-list>
  </main>

  <script>
  // DraggableBehavior - Pure drag and drop logic, reusable
  class DraggableBehavior {
    constructor(container, options = {}) {
      this.container = container;
      this.options = {
        handleClass: 'handle',
        threshold: 10,
        onReorder: null,
        ...options
      };
      this.dragging = null;
      this.touchStartY = 0;
      this.touchStartX = 0;
      this.isTouchDragging = false;
      this.rafId = null;
      this.cachedItems = null;
      this.enabled = false;
      this.placeholder = null;
      this.originalPosition = null;
    }

    enable() {
      if (this.enabled) return;
      this.enabled = true;
      this.setupEventListeners();
    }

    disable() {
      if (!this.enabled) return;
      this.enabled = false;
      this.removeEventListeners();
    }

    destroy() {
      this.disable();
      this.container = null;
    }

    setupEventListeners() {
      // Mouse events
      this.container.addEventListener('dragstart', this.handleDragStart.bind(this));
      this.container.addEventListener('dragend', this.handleDragEnd.bind(this));
      this.container.addEventListener('dragover', this.handleDragOver.bind(this));
      this.container.addEventListener('drop', this.handleDrop.bind(this));

      // Touch events
      this.container.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: true });
      this.container.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
      this.container.addEventListener('touchend', this.handleTouchEnd.bind(this), { passive: true });
    }

    removeEventListeners() {
      this.container.removeEventListener('dragstart', this.handleDragStart.bind(this));
      this.container.removeEventListener('dragend', this.handleDragEnd.bind(this));
      this.container.removeEventListener('dragover', this.handleDragOver.bind(this));
      this.container.removeEventListener('drop', this.handleDrop.bind(this));
      this.container.removeEventListener('touchstart', this.handleTouchStart.bind(this));
      this.container.removeEventListener('touchmove', this.handleTouchMove.bind(this));
      this.container.removeEventListener('touchend', this.handleTouchEnd.bind(this));
    }

    // Mouse event handlers
    handleDragStart(e) {
      const li = e.target.closest('li');
      if (!li) return;
      this.startDrag(li);
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', '');
      
      // Suppress the drag image by setting an empty/transparent image
      const emptyImg = document.createElement('img');
      emptyImg.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAUEBAAAACwAAAAAAQABAAACAkQBADs=';
      e.dataTransfer.setDragImage(emptyImg, 0, 0);
    }

    handleDragEnd() {
      this.endDrag();
    }

    handleDragOver(e) {
      e.preventDefault();
      this.debouncedDragOver(e.clientY);
      e.dataTransfer.dropEffect = 'move';
    }

    handleDrop(e) {
      e.preventDefault();
      this.drop(e.clientY);
      this.endDrag();
    }

    // Touch event handlers
    handleTouchStart(e) {
      if (!e.target.classList.contains(this.options.handleClass)) return;
      const li = e.target.closest('li');
      if (!li) return;
      this.touchStartY = e.touches[0].clientY;
      this.touchStartX = e.touches[0].clientX;
      // setting touch dragging to false as we haven't yet checked the threshold
      this.isTouchDragging = false;
    }

    handleTouchMove(e) {
      if (!e.target.classList.contains(this.options.handleClass)) return;
      if (!this.isTouchDragging) {
        const deltaY = Math.abs(e.touches[0].clientY - this.touchStartY);
        const deltaX = Math.abs(e.touches[0].clientX - this.touchStartX);
        const totalDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        // now we can check whether we really started dragging in touchstart
        // we check whether the total movement dragged is more than a threshold in pixels
        // this prevents the dragging to trigger with the smallest movement
        if (totalDistance > this.options.threshold) {
          const li = e.target.closest('li');
          if (li) {
            this.isTouchDragging = true;
            this.startDrag(li);
            if (e.cancelable) {
              e.preventDefault();
            }
          }
        }
      } else if (this.dragging) {
        if (e.cancelable) {
          e.preventDefault();
        }
        this.debouncedDragOver(e.touches[0].clientY);
      }
    }

    handleTouchEnd(e) {
      if (this.isTouchDragging && this.dragging) {
        this.drop(e.changedTouches[0].clientY);
        this.endDrag();
      }
    }

    // Core drag logic
    startDrag(li) {
      this.dragging = li;
      li.classList.add('dragging');
      this.originalPosition = this.getIndex(li);
      this.invalidateItemsCache();      
    }

    endDrag() {
      // If drag was cancelled (no drop), restore original position
      if (this.dragging && this.originalPosition !== null) {
        this.restoreOriginalPosition();
      }
      this.dragging?.classList.remove('dragging');
      this.dragging = null;
      this.isTouchDragging = false;
      this.originalPosition = null;
      this.invalidateItemsCache();
    }

    dragOver(clientY) {
      if (!this.dragging) return;
      const after = this.getDropTarget(clientY);
      this.moveDraggedElement(after);
    }

    debouncedDragOver(clientY) {
      if (this.rafId) cancelAnimationFrame(this.rafId);
      this.rafId = requestAnimationFrame(() => {
        this.dragOver(clientY);
        this.rafId = null;
      });
    }

    drop(clientY) {
      if (!this.dragging) return;
      const after = this.getDropTarget(clientY);
      
      // Final position is already set by moveDraggedElement during drag
      // Mark as successfully dropped so endDrag won't restore position
      this.originalPosition = null;
      
      this.dragging.classList.remove('dragging');
      this.invalidateItemsCache();
      
      this.dragging.classList.add('drop-animation');
      const animatedDragging = this.dragging;
      setTimeout(() => animatedDragging.classList.remove('drop-animation'), 300);

      if (this.options.onReorder) {
        const fromIndex = this.getIndex(this.dragging);
        const toIndex = after ? this.getIndex(after) : this.container.children.length - 1;
        this.options.onReorder(fromIndex, toIndex);
      }
    }

    getDropTarget(mouseY) {
      if (!this.cachedItems) {
        this.cachedItems = [...this.container.querySelectorAll('li:not(.dragging)')];
      }
      if (this.cachedItems.length === 0) return null;
      
      let left = 0;
      let right = this.cachedItems.length;
      
      while (left < right) {
        const mid = Math.floor((left + right) / 2);
        const rect = this.cachedItems[mid].getBoundingClientRect();
        const midY = rect.top + rect.height / 2;
        
        if (mouseY < midY) {
          right = mid;
        } else {
          left = mid + 1;
        }
      }
      
      return left < this.cachedItems.length ? this.cachedItems[left] : null;
    }

    getIndex(element) {
      return Array.from(this.container.children).indexOf(element);
    }

    invalidateItemsCache() {
      this.cachedItems = null;
    }

    moveDraggedElement(after) {
      if (!this.dragging) return;
      
      // Move the dragged element to the new position
      if (after == null) {
        this.container.appendChild(this.dragging);
      } else {
        this.container.insertBefore(this.dragging, after);
      }
    }

    restoreOriginalPosition() {
      if (!this.dragging || this.originalPosition === null) return;
      
      const children = Array.from(this.container.children);
      const targetIndex = Math.min(this.originalPosition, children.length - 1);
      const targetElement = children[targetIndex];
      
      if (targetElement && targetElement !== this.dragging) {
        this.container.insertBefore(this.dragging, targetElement);
      } else if (targetIndex === children.length - 1) {
        this.container.appendChild(this.dragging);
      }
    }
  }

  // TodoList Web Component - extends HTMLOListElement
  class TodoList extends HTMLOListElement {
    constructor() {
      super();
      this.dragBehavior = null;
    }

    connectedCallback() {
      this.setupDragAndDrop();
    }

    disconnectedCallback() {
      this.dragBehavior?.destroy();
    }

    setupDragAndDrop() {
      this.dragBehavior = new DraggableBehavior(this, {
        handleClass: 'handle',
        onReorder: (fromIndex, toIndex) => {
          console.log(`Moved item from ${fromIndex} to ${toIndex}`);
          // Emit custom event for external listeners
          this.dispatchEvent(new CustomEvent('reorder', {
            detail: { fromIndex, toIndex }
          }));
        }
      });
      this.dragBehavior.enable();
    }
  }

  // Register the custom element as extending ol
  customElements.define('todo-list', TodoList, { extends: 'ol' });
</script>
</body>
</html>
