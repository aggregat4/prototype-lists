<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Prototype Lists</title>
<style>
  body {
    font-family: Inter, sans-serif;
    padding: 0;
    font-size: 18px;
  }
  main {
    max-width: 800px;
    margin: 0 auto;
    /* padding: 1rem; */
  }
  ol.tasklist {
    padding: 12px;
    margin: 0;
    list-style-type: none;
    background-color: #f5f5f5;
  }
  .tasklist li {
    padding: 6px 6px;
    margin-bottom: 12px;
    background-color: white;
    border: 1px solid #a1a1a1;
    border-bottom: 2px solid #4d4d4d;
    display: flex;
    align-items: center;
  }
  .tasklist li .handle {
    margin-left: auto;
    padding: 8px;
    cursor: grab;
    color: #999;
    user-select: none;
  }
  .tasklist li .handle:active { cursor: grabbing; }
  .tasklist > li:active { cursor: grabbing; }
  .tasklist > li.dragging { opacity: .6; }
  /* subtle drop indicators */
  .tasklist > li.drop-before { box-shadow: 0 -2px 0 0 currentColor inset; }
  .tasklist > li.drop-after  { box-shadow: 0  2px 0 0 currentColor inset; }
  
  /* drop animation */
  .tasklist > li.drop-animation {
    animation: dropSlide 0.3s ease-out;
  }
  
  @keyframes dropSlide {
    0% {
      transform: translateX(-8px);
      opacity: 0.7;
    }
    50% {
      transform: translateX(8px);
      opacity: 0.7;
    }
    100% {
      transform: translateX(0);
      opacity: 1;
    }
  }
</style>

</head>
<body>

  <main>
    <ol id="tasks" class="tasklist">
      <li draggable="true">Refill the bird feeder before the sparrows file another formal request.<span class="handle">⋮⋮</span></li>
      <li draggable="true">Check the fridge light still turns off, preferably without crawling inside again.<span class="handle">⋮⋮</span></li>
      <li draggable="true">Return the umbrella to the hallway, where it insists it lives.<span class="handle">⋮⋮</span></li>
      <li draggable="true">Water the fern before it submits another strongly worded letter to the radiator.<span class="handle">⋮⋮</span></li>
      <li draggable="true">Update the shopping list to include milk, bread, and a moderately sensible hat.<span class="handle">⋮⋮</span></li>
      <li draggable="true">Verify that the kettle boils water and not, as it occasionally attempts, good intentions.<span class="handle">⋮⋮</span></li>
      <li draggable="true">Organize the cutlery drawer so the forks don't keep holding union meetings.<span class="handle">⋮⋮</span></li>
      <li draggable="true">Empty the dishwasher before it begins drafting poetry about neglect.<span class="handle">⋮⋮</span></li>
      <li draggable="true">Set the alarm clock, reminding it gently that no one enjoys its personality.<span class="handle">⋮⋮</span></li>
      <li draggable="true">Take the bins out, though they are increasingly insistent they'd rather stay in.<span class="handle">⋮⋮</span></li>
      <li draggable="true">Test the smoke detector by asking it politely to explain its worldview.<span class="handle">⋮⋮</span></li>
      <li draggable="true">Send an email to the electricity meter thanking it for its tireless blinking.<span class="handle">⋮⋮</span></li>
      <li draggable="true">Sharpen pencils so they feel prepared for anything, including international diplomacy.<span class="handle">⋮⋮</span></li>
      <li draggable="true">Update the calendar to reflect the current year, not the one the cat prefers.<span class="handle">⋮⋮</span></li>
      <li draggable="true">Polish the windows until they are clear about their long-term career goals.<span class="handle">⋮⋮</span></li>
      <li draggable="true">Check the washing machine for socks that have declared independence.<span class="handle">⋮⋮</span></li>
      <li draggable="true">Restock the biscuit tin before negotiations with visitors turn awkward.<span class="handle">⋮⋮</span></li>
      <li draggable="true">Feed the goldfish, who has recently taken to sighing at odd intervals.<span class="handle">⋮⋮</span></li>
      <li draggable="true">Write down the Wi-Fi password in case it decides to change its name again.<span class="handle">⋮⋮</span></li>
      <li draggable="true">Vacuum the carpet before it develops further geological features.<span class="handle">⋮⋮</span></li>
    </ol>
  </main>

  <script>
  const list = document.getElementById('tasks');
  let dragging = null;
  let touchStartY = 0;
  let isTouchDragging = false;

  list.addEventListener('dragstart', (e) => {
    const li = e.target.closest('li');
    if (!li) return;
    dragging = li;
    li.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/plain', ''); // Firefox requires setData
  });

  list.addEventListener('dragend', () => {
    cleanupIndicators();
    dragging?.classList.remove('dragging');
    dragging = null;
  });

  list.addEventListener('dragover', (e) => {
    if (!dragging) return;
    e.preventDefault(); // allow drop
    const after = getDropTarget(list, e.clientY);

    // visual cues
    cleanupIndicators();
    if (after == null) {
      list.lastElementChild?.classList.add('drop-before');
    } else {
      after.classList.add('drop-after');
    }

    e.dataTransfer.dropEffect = 'move';
  });

  list.addEventListener('drop', (e) => {
    if (!dragging) return;
    e.preventDefault();
    const after = getDropTarget(list, e.clientY);
    if (after == null) list.appendChild(dragging);
    else list.insertBefore(dragging, after);
    cleanupIndicators();
    
    // Trigger drop animation
    dragging.classList.add('drop-animation');
    setTimeout(() => {
      dragging.classList.remove('drop-animation');
    }, 300); // Match animation duration
  });

  function getDropTarget(container, mouseY) {
    // Find the closest non-dragging LI above the pointer’s midpoint
    const items = [...container.querySelectorAll('li:not(.dragging)')];
    let closest = { offset: Number.NEGATIVE_INFINITY, el: null };
    for (const el of items) {
      const r = el.getBoundingClientRect();
      const offset = mouseY - (r.top + r.height / 2);
      if (offset < 0 && offset > closest.offset) closest = { offset, el };
    }
    return closest.el; // null => append at end
  }

  function cleanupIndicators() {
    list.querySelectorAll('.drop-before, .drop-after').forEach(li => {
      li.classList.remove('drop-before', 'drop-after');
    });
  }

  // Touch support
  list.addEventListener('touchstart', (e) => {
    const li = e.target.closest('li');
    if (!li) return;
    touchStartY = e.touches[0].clientY;
    isTouchDragging = false;
  }, { passive: true });

  list.addEventListener('touchmove', (e) => {
    if (!isTouchDragging && Math.abs(e.touches[0].clientY - touchStartY) > 10) {
      const li = e.target.closest('li');
      if (li) {
        isTouchDragging = true;
        dragging = li;
        li.classList.add('dragging');
        e.preventDefault();
      }
    }
    if (isTouchDragging && dragging) {
      e.preventDefault();
      const after = getDropTarget(list, e.touches[0].clientY);
      cleanupIndicators();
      if (after == null) {
        list.lastElementChild?.classList.add('drop-before');
      } else {
        after.classList.add('drop-after');
      }
    }
  }, { passive: false });

  list.addEventListener('touchend', (e) => {
    if (isTouchDragging && dragging) {
      const after = getDropTarget(list, e.changedTouches[0].clientY);
      if (after == null) list.appendChild(dragging);
      else list.insertBefore(dragging, after);
      cleanupIndicators();
      dragging.classList.add('drop-animation');
      setTimeout(() => dragging.classList.remove('drop-animation'), 300);
      dragging.classList.remove('dragging');
      dragging = null;
      isTouchDragging = false;
    }
  }, { passive: true });
</script>
</body>
</html>
